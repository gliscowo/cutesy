// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

class FreetypeLibrary {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  FreetypeLibrary(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  FreetypeLibrary.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  ffi.Pointer<ffi.Void> memcpy(
    ffi.Pointer<ffi.Void> __dest,
    ffi.Pointer<ffi.Void> __src,
    int __n,
  ) {
    return _memcpy(
      __dest,
      __src,
      __n,
    );
  }

  late final _memcpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('memcpy');
  late final _memcpy = _memcpyPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> memmove(
    ffi.Pointer<ffi.Void> __dest,
    ffi.Pointer<ffi.Void> __src,
    int __n,
  ) {
    return _memmove(
      __dest,
      __src,
      __n,
    );
  }

  late final _memmovePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('memmove');
  late final _memmove = _memmovePtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> memccpy(
    ffi.Pointer<ffi.Void> __dest,
    ffi.Pointer<ffi.Void> __src,
    int __c,
    int __n,
  ) {
    return _memccpy(
      __dest,
      __src,
      __c,
      __n,
    );
  }

  late final _memccpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('memccpy');
  late final _memccpy = _memccpyPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> memset(
    ffi.Pointer<ffi.Void> __s,
    int __c,
    int __n,
  ) {
    return _memset(
      __s,
      __c,
      __n,
    );
  }

  late final _memsetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('memset');
  late final _memset = _memsetPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  int memcmp(
    ffi.Pointer<ffi.Void> __s1,
    ffi.Pointer<ffi.Void> __s2,
    int __n,
  ) {
    return _memcmp(
      __s1,
      __s2,
      __n,
    );
  }

  late final _memcmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('memcmp');
  late final _memcmp = _memcmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int __memcmpeq(
    ffi.Pointer<ffi.Void> __s1,
    ffi.Pointer<ffi.Void> __s2,
    int __n,
  ) {
    return ___memcmpeq(
      __s1,
      __s2,
      __n,
    );
  }

  late final ___memcmpeqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('__memcmpeq');
  late final ___memcmpeq = ___memcmpeqPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> memchr(
    ffi.Pointer<ffi.Void> __s,
    int __c,
    int __n,
  ) {
    return _memchr(
      __s,
      __c,
      __n,
    );
  }

  late final _memchrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('memchr');
  late final _memchr = _memchrPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Char> strcpy(
    ffi.Pointer<ffi.Char> __dest,
    ffi.Pointer<ffi.Char> __src,
  ) {
    return _strcpy(
      __dest,
      __src,
    );
  }

  late final _strcpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcpy');
  late final _strcpy = _strcpyPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strncpy(
    ffi.Pointer<ffi.Char> __dest,
    ffi.Pointer<ffi.Char> __src,
    int __n,
  ) {
    return _strncpy(
      __dest,
      __src,
      __n,
    );
  }

  late final _strncpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strncpy');
  late final _strncpy = _strncpyPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strcat(
    ffi.Pointer<ffi.Char> __dest,
    ffi.Pointer<ffi.Char> __src,
  ) {
    return _strcat(
      __dest,
      __src,
    );
  }

  late final _strcatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcat');
  late final _strcat = _strcatPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strncat(
    ffi.Pointer<ffi.Char> __dest,
    ffi.Pointer<ffi.Char> __src,
    int __n,
  ) {
    return _strncat(
      __dest,
      __src,
      __n,
    );
  }

  late final _strncatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strncat');
  late final _strncat = _strncatPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int strcmp(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
  ) {
    return _strcmp(
      __s1,
      __s2,
    );
  }

  late final _strcmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcmp');
  late final _strcmp = _strcmpPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int strncmp(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
    int __n,
  ) {
    return _strncmp(
      __s1,
      __s2,
      __n,
    );
  }

  late final _strncmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('strncmp');
  late final _strncmp = _strncmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int strcoll(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
  ) {
    return _strcoll(
      __s1,
      __s2,
    );
  }

  late final _strcollPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcoll');
  late final _strcoll = _strcollPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int strxfrm(
    ffi.Pointer<ffi.Char> __dest,
    ffi.Pointer<ffi.Char> __src,
    int __n,
  ) {
    return _strxfrm(
      __dest,
      __src,
      __n,
    );
  }

  late final _strxfrmPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strxfrm');
  late final _strxfrm = _strxfrmPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int strcoll_l(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
    locale_t __l,
  ) {
    return _strcoll_l(
      __s1,
      __s2,
      __l,
    );
  }

  late final _strcoll_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              locale_t)>>('strcoll_l');
  late final _strcoll_l = _strcoll_lPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, locale_t)>();

  int strxfrm_l(
    ffi.Pointer<ffi.Char> __dest,
    ffi.Pointer<ffi.Char> __src,
    int __n,
    locale_t __l,
  ) {
    return _strxfrm_l(
      __dest,
      __src,
      __n,
      __l,
    );
  }

  late final _strxfrm_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size, locale_t)>>('strxfrm_l');
  late final _strxfrm_l = _strxfrm_lPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int, locale_t)>();

  ffi.Pointer<ffi.Char> strdup(
    ffi.Pointer<ffi.Char> __s,
  ) {
    return _strdup(
      __s,
    );
  }

  late final _strdupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('strdup');
  late final _strdup = _strdupPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strndup(
    ffi.Pointer<ffi.Char> __string,
    int __n,
  ) {
    return _strndup(
      __string,
      __n,
    );
  }

  late final _strndupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strndup');
  late final _strndup = _strndupPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strchr(
    ffi.Pointer<ffi.Char> __s,
    int __c,
  ) {
    return _strchr(
      __s,
      __c,
    );
  }

  late final _strchrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('strchr');
  late final _strchr = _strchrPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strrchr(
    ffi.Pointer<ffi.Char> __s,
    int __c,
  ) {
    return _strrchr(
      __s,
      __c,
    );
  }

  late final _strrchrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('strrchr');
  late final _strrchr = _strrchrPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  int strcspn(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __reject,
  ) {
    return _strcspn(
      __s,
      __reject,
    );
  }

  late final _strcspnPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcspn');
  late final _strcspn = _strcspnPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int strspn(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __accept,
  ) {
    return _strspn(
      __s,
      __accept,
    );
  }

  late final _strspnPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strspn');
  late final _strspn = _strspnPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strpbrk(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __accept,
  ) {
    return _strpbrk(
      __s,
      __accept,
    );
  }

  late final _strpbrkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strpbrk');
  late final _strpbrk = _strpbrkPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strstr(
    ffi.Pointer<ffi.Char> __haystack,
    ffi.Pointer<ffi.Char> __needle,
  ) {
    return _strstr(
      __haystack,
      __needle,
    );
  }

  late final _strstrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strstr');
  late final _strstr = _strstrPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strtok(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __delim,
  ) {
    return _strtok(
      __s,
      __delim,
    );
  }

  late final _strtokPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strtok');
  late final _strtok = _strtokPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> __strtok_r(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __delim,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __save_ptr,
  ) {
    return ___strtok_r(
      __s,
      __delim,
      __save_ptr,
    );
  }

  late final ___strtok_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('__strtok_r');
  late final ___strtok_r = ___strtok_rPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  ffi.Pointer<ffi.Char> strtok_r(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __delim,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __save_ptr,
  ) {
    return _strtok_r(
      __s,
      __delim,
      __save_ptr,
    );
  }

  late final _strtok_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('strtok_r');
  late final _strtok_r = _strtok_rPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int strlen(
    ffi.Pointer<ffi.Char> __s,
  ) {
    return _strlen(
      __s,
    );
  }

  late final _strlenPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>)>>(
      'strlen');
  late final _strlen =
      _strlenPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int strnlen(
    ffi.Pointer<ffi.Char> __string,
    int __maxlen,
  ) {
    return _strnlen(
      __string,
      __maxlen,
    );
  }

  late final _strnlenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Size)>>('strnlen');
  late final _strnlen =
      _strnlenPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strerror(
    int __errnum,
  ) {
    return _strerror(
      __errnum,
    );
  }

  late final _strerrorPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'strerror');
  late final _strerror =
      _strerrorPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  int strerror_r(
    int __errnum,
    ffi.Pointer<ffi.Char> __buf,
    int __buflen,
  ) {
    return _strerror_r(
      __errnum,
      __buf,
      __buflen,
    );
  }

  late final _strerror_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Size)>>('strerror_r');
  late final _strerror_r = _strerror_rPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strerror_l(
    int __errnum,
    locale_t __l,
  ) {
    return _strerror_l(
      __errnum,
      __l,
    );
  }

  late final _strerror_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Int, locale_t)>>('strerror_l');
  late final _strerror_l = _strerror_lPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int, locale_t)>();

  int bcmp(
    ffi.Pointer<ffi.Void> __s1,
    ffi.Pointer<ffi.Void> __s2,
    int __n,
  ) {
    return _bcmp(
      __s1,
      __s2,
      __n,
    );
  }

  late final _bcmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Size)>>('bcmp');
  late final _bcmp = _bcmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  void bcopy(
    ffi.Pointer<ffi.Void> __src,
    ffi.Pointer<ffi.Void> __dest,
    int __n,
  ) {
    return _bcopy(
      __src,
      __dest,
      __n,
    );
  }

  late final _bcopyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('bcopy');
  late final _bcopy = _bcopyPtr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  void bzero(
    ffi.Pointer<ffi.Void> __s,
    int __n,
  ) {
    return _bzero(
      __s,
      __n,
    );
  }

  late final _bzeroPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Size)>>('bzero');
  late final _bzero =
      _bzeroPtr.asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Char> index(
    ffi.Pointer<ffi.Char> __s,
    int __c,
  ) {
    return _index(
      __s,
      __c,
    );
  }

  late final _indexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('index');
  late final _index = _indexPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> rindex(
    ffi.Pointer<ffi.Char> __s,
    int __c,
  ) {
    return _rindex(
      __s,
      __c,
    );
  }

  late final _rindexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('rindex');
  late final _rindex = _rindexPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  int ffs(
    int __i,
  ) {
    return _ffs(
      __i,
    );
  }

  late final _ffsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('ffs');
  late final _ffs = _ffsPtr.asFunction<int Function(int)>();

  int ffsl(
    int __l,
  ) {
    return _ffsl(
      __l,
    );
  }

  late final _ffslPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Long)>>('ffsl');
  late final _ffsl = _ffslPtr.asFunction<int Function(int)>();

  int ffsll(
    int __ll,
  ) {
    return _ffsll(
      __ll,
    );
  }

  late final _ffsllPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.LongLong)>>('ffsll');
  late final _ffsll = _ffsllPtr.asFunction<int Function(int)>();

  int strcasecmp(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
  ) {
    return _strcasecmp(
      __s1,
      __s2,
    );
  }

  late final _strcasecmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcasecmp');
  late final _strcasecmp = _strcasecmpPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int strncasecmp(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
    int __n,
  ) {
    return _strncasecmp(
      __s1,
      __s2,
      __n,
    );
  }

  late final _strncasecmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('strncasecmp');
  late final _strncasecmp = _strncasecmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int strcasecmp_l(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
    locale_t __loc,
  ) {
    return _strcasecmp_l(
      __s1,
      __s2,
      __loc,
    );
  }

  late final _strcasecmp_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              locale_t)>>('strcasecmp_l');
  late final _strcasecmp_l = _strcasecmp_lPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, locale_t)>();

  int strncasecmp_l(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
    int __n,
    locale_t __loc,
  ) {
    return _strncasecmp_l(
      __s1,
      __s2,
      __n,
      __loc,
    );
  }

  late final _strncasecmp_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size, locale_t)>>('strncasecmp_l');
  late final _strncasecmp_l = _strncasecmp_lPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int, locale_t)>();

  void explicit_bzero(
    ffi.Pointer<ffi.Void> __s,
    int __n,
  ) {
    return _explicit_bzero(
      __s,
      __n,
    );
  }

  late final _explicit_bzeroPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('explicit_bzero');
  late final _explicit_bzero = _explicit_bzeroPtr
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Char> strsep(
    ffi.Pointer<ffi.Pointer<ffi.Char>> __stringp,
    ffi.Pointer<ffi.Char> __delim,
  ) {
    return _strsep(
      __stringp,
      __delim,
    );
  }

  late final _strsepPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('strsep');
  late final _strsep = _strsepPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strsignal(
    int __sig,
  ) {
    return _strsignal(
      __sig,
    );
  }

  late final _strsignalPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'strsignal');
  late final _strsignal =
      _strsignalPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  ffi.Pointer<ffi.Char> __stpcpy(
    ffi.Pointer<ffi.Char> __dest,
    ffi.Pointer<ffi.Char> __src,
  ) {
    return ___stpcpy(
      __dest,
      __src,
    );
  }

  late final ___stpcpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('__stpcpy');
  late final ___stpcpy = ___stpcpyPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> stpcpy(
    ffi.Pointer<ffi.Char> __dest,
    ffi.Pointer<ffi.Char> __src,
  ) {
    return _stpcpy(
      __dest,
      __src,
    );
  }

  late final _stpcpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('stpcpy');
  late final _stpcpy = _stpcpyPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> __stpncpy(
    ffi.Pointer<ffi.Char> __dest,
    ffi.Pointer<ffi.Char> __src,
    int __n,
  ) {
    return ___stpncpy(
      __dest,
      __src,
      __n,
    );
  }

  late final ___stpncpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('__stpncpy');
  late final ___stpncpy = ___stpncpyPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> stpncpy(
    ffi.Pointer<ffi.Char> __dest,
    ffi.Pointer<ffi.Char> __src,
    int __n,
  ) {
    return _stpncpy(
      __dest,
      __src,
      __n,
    );
  }

  late final _stpncpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('stpncpy');
  late final _stpncpy = _stpncpyPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  late final ffi.Pointer<ffi.Pointer<FILE>> _stdin =
      _lookup<ffi.Pointer<FILE>>('stdin');

  ffi.Pointer<FILE> get stdin => _stdin.value;

  set stdin(ffi.Pointer<FILE> value) => _stdin.value = value;

  late final ffi.Pointer<ffi.Pointer<FILE>> _stdout =
      _lookup<ffi.Pointer<FILE>>('stdout');

  ffi.Pointer<FILE> get stdout => _stdout.value;

  set stdout(ffi.Pointer<FILE> value) => _stdout.value = value;

  late final ffi.Pointer<ffi.Pointer<FILE>> _stderr =
      _lookup<ffi.Pointer<FILE>>('stderr');

  ffi.Pointer<FILE> get stderr => _stderr.value;

  set stderr(ffi.Pointer<FILE> value) => _stderr.value = value;

  int remove(
    ffi.Pointer<ffi.Char> __filename,
  ) {
    return _remove(
      __filename,
    );
  }

  late final _removePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'remove');
  late final _remove =
      _removePtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int rename(
    ffi.Pointer<ffi.Char> __old,
    ffi.Pointer<ffi.Char> __new,
  ) {
    return _rename(
      __old,
      __new,
    );
  }

  late final _renamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('rename');
  late final _rename = _renamePtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int renameat(
    int __oldfd,
    ffi.Pointer<ffi.Char> __old,
    int __newfd,
    ffi.Pointer<ffi.Char> __new,
  ) {
    return _renameat(
      __oldfd,
      __old,
      __newfd,
      __new,
    );
  }

  late final _renameatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Pointer<ffi.Char>)>>('renameat');
  late final _renameat = _renameatPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int fclose(
    ffi.Pointer<FILE> __stream,
  ) {
    return _fclose(
      __stream,
    );
  }

  late final _fclosePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'fclose');
  late final _fclose = _fclosePtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  ffi.Pointer<FILE> tmpfile() {
    return _tmpfile();
  }

  late final _tmpfilePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<FILE> Function()>>('tmpfile');
  late final _tmpfile = _tmpfilePtr.asFunction<ffi.Pointer<FILE> Function()>();

  ffi.Pointer<ffi.Char> tmpnam(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _tmpnam(
      arg0,
    );
  }

  late final _tmpnamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('tmpnam');
  late final _tmpnam = _tmpnamPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> tmpnam_r(
    ffi.Pointer<ffi.Char> __s,
  ) {
    return _tmpnam_r(
      __s,
    );
  }

  late final _tmpnam_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('tmpnam_r');
  late final _tmpnam_r = _tmpnam_rPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> tempnam(
    ffi.Pointer<ffi.Char> __dir,
    ffi.Pointer<ffi.Char> __pfx,
  ) {
    return _tempnam(
      __dir,
      __pfx,
    );
  }

  late final _tempnamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('tempnam');
  late final _tempnam = _tempnamPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int fflush(
    ffi.Pointer<FILE> __stream,
  ) {
    return _fflush(
      __stream,
    );
  }

  late final _fflushPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'fflush');
  late final _fflush = _fflushPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int fflush_unlocked(
    ffi.Pointer<FILE> __stream,
  ) {
    return _fflush_unlocked(
      __stream,
    );
  }

  late final _fflush_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'fflush_unlocked');
  late final _fflush_unlocked =
      _fflush_unlockedPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  ffi.Pointer<FILE> fopen(
    ffi.Pointer<ffi.Char> __filename,
    ffi.Pointer<ffi.Char> __modes,
  ) {
    return _fopen(
      __filename,
      __modes,
    );
  }

  late final _fopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('fopen');
  late final _fopen = _fopenPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<FILE> freopen(
    ffi.Pointer<ffi.Char> __filename,
    ffi.Pointer<ffi.Char> __modes,
    ffi.Pointer<FILE> __stream,
  ) {
    return _freopen(
      __filename,
      __modes,
      __stream,
    );
  }

  late final _freopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<FILE>)>>('freopen');
  late final _freopen = _freopenPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, ffi.Pointer<FILE>)>();

  ffi.Pointer<FILE> fdopen(
    int __fd,
    ffi.Pointer<ffi.Char> __modes,
  ) {
    return _fdopen(
      __fd,
      __modes,
    );
  }

  late final _fdopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(
              ffi.Int, ffi.Pointer<ffi.Char>)>>('fdopen');
  late final _fdopen = _fdopenPtr
      .asFunction<ffi.Pointer<FILE> Function(int, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<FILE> fmemopen(
    ffi.Pointer<ffi.Void> __s,
    int __len,
    ffi.Pointer<ffi.Char> __modes,
  ) {
    return _fmemopen(
      __s,
      __len,
      __modes,
    );
  }

  late final _fmemopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(ffi.Pointer<ffi.Void>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('fmemopen');
  late final _fmemopen = _fmemopenPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<FILE> open_memstream(
    ffi.Pointer<ffi.Pointer<ffi.Char>> __bufloc,
    ffi.Pointer<ffi.Size> __sizeloc,
  ) {
    return _open_memstream(
      __bufloc,
      __sizeloc,
    );
  }

  late final _open_memstreamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>)>>('open_memstream');
  late final _open_memstream = _open_memstreamPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Size>)>();

  void setbuf(
    ffi.Pointer<FILE> __stream,
    ffi.Pointer<ffi.Char> __buf,
  ) {
    return _setbuf(
      __stream,
      __buf,
    );
  }

  late final _setbufPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>>('setbuf');
  late final _setbuf = _setbufPtr
      .asFunction<void Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>();

  int setvbuf(
    ffi.Pointer<FILE> __stream,
    ffi.Pointer<ffi.Char> __buf,
    int __modes,
    int __n,
  ) {
    return _setvbuf(
      __stream,
      __buf,
      __modes,
      __n,
    );
  }

  late final _setvbufPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Size)>>('setvbuf');
  late final _setvbuf = _setvbufPtr.asFunction<
      int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, int, int)>();

  void setbuffer(
    ffi.Pointer<FILE> __stream,
    ffi.Pointer<ffi.Char> __buf,
    int __size,
  ) {
    return _setbuffer(
      __stream,
      __buf,
      __size,
    );
  }

  late final _setbufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('setbuffer');
  late final _setbuffer = _setbufferPtr.asFunction<
      void Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, int)>();

  void setlinebuf(
    ffi.Pointer<FILE> __stream,
  ) {
    return _setlinebuf(
      __stream,
    );
  }

  late final _setlinebufPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FILE>)>>(
          'setlinebuf');
  late final _setlinebuf =
      _setlinebufPtr.asFunction<void Function(ffi.Pointer<FILE>)>();

  int fprintf(
    ffi.Pointer<FILE> __stream,
    ffi.Pointer<ffi.Char> __format,
  ) {
    return _fprintf(
      __stream,
      __format,
    );
  }

  late final _fprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>>('fprintf');
  late final _fprintf = _fprintfPtr
      .asFunction<int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>();

  int printf(
    ffi.Pointer<ffi.Char> __format,
  ) {
    return _printf(
      __format,
    );
  }

  late final _printfPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'printf');
  late final _printf =
      _printfPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int sprintf(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __format,
  ) {
    return _sprintf(
      __s,
      __format,
    );
  }

  late final _sprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('sprintf');
  late final _sprintf = _sprintfPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int vfprintf(
    ffi.Pointer<FILE> __s,
    ffi.Pointer<ffi.Char> __format,
    ffi.Pointer<__va_list_tag> __arg,
  ) {
    return _vfprintf(
      __s,
      __format,
      __arg,
    );
  }

  late final _vfprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<__va_list_tag>)>>('vfprintf');
  late final _vfprintf = _vfprintfPtr.asFunction<
      int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<__va_list_tag>)>();

  int vprintf(
    ffi.Pointer<ffi.Char> __format,
    ffi.Pointer<__va_list_tag> __arg,
  ) {
    return _vprintf(
      __format,
      __arg,
    );
  }

  late final _vprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<__va_list_tag>)>>('vprintf');
  late final _vprintf = _vprintfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<__va_list_tag>)>();

  int vsprintf(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __format,
    ffi.Pointer<__va_list_tag> __arg,
  ) {
    return _vsprintf(
      __s,
      __format,
      __arg,
    );
  }

  late final _vsprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<__va_list_tag>)>>('vsprintf');
  late final _vsprintf = _vsprintfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<__va_list_tag>)>();

  int snprintf(
    ffi.Pointer<ffi.Char> __s,
    int __maxlen,
    ffi.Pointer<ffi.Char> __format,
  ) {
    return _snprintf(
      __s,
      __maxlen,
      __format,
    );
  }

  late final _snprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('snprintf');
  late final _snprintf = _snprintfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int vsnprintf(
    ffi.Pointer<ffi.Char> __s,
    int __maxlen,
    ffi.Pointer<ffi.Char> __format,
    ffi.Pointer<__va_list_tag> __arg,
  ) {
    return _vsnprintf(
      __s,
      __maxlen,
      __format,
      __arg,
    );
  }

  late final _vsnprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>, ffi.Pointer<__va_list_tag>)>>('vsnprintf');
  late final _vsnprintf = _vsnprintfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>,
          ffi.Pointer<__va_list_tag>)>();

  int vdprintf(
    int __fd,
    ffi.Pointer<ffi.Char> __fmt,
    ffi.Pointer<__va_list_tag> __arg,
  ) {
    return _vdprintf(
      __fd,
      __fmt,
      __arg,
    );
  }

  late final _vdprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>,
              ffi.Pointer<__va_list_tag>)>>('vdprintf');
  late final _vdprintf = _vdprintfPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Char>, ffi.Pointer<__va_list_tag>)>();

  int dprintf(
    int __fd,
    ffi.Pointer<ffi.Char> __fmt,
  ) {
    return _dprintf(
      __fd,
      __fmt,
    );
  }

  late final _dprintfPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>)>>(
      'dprintf');
  late final _dprintf =
      _dprintfPtr.asFunction<int Function(int, ffi.Pointer<ffi.Char>)>();

  int fscanf(
    ffi.Pointer<FILE> __stream,
    ffi.Pointer<ffi.Char> __format,
  ) {
    return _fscanf(
      __stream,
      __format,
    );
  }

  late final _fscanfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>>('fscanf');
  late final _fscanf = _fscanfPtr
      .asFunction<int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>();

  int scanf(
    ffi.Pointer<ffi.Char> __format,
  ) {
    return _scanf(
      __format,
    );
  }

  late final _scanfPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'scanf');
  late final _scanf =
      _scanfPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int sscanf(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __format,
  ) {
    return _sscanf(
      __s,
      __format,
    );
  }

  late final _sscanfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('sscanf');
  late final _sscanf = _sscanfPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int fscanf1(
    ffi.Pointer<FILE> __stream,
    ffi.Pointer<ffi.Char> __format,
  ) {
    return _fscanf1(
      __stream,
      __format,
    );
  }

  late final _fscanf1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>>('fscanf');
  late final _fscanf1 = _fscanf1Ptr
      .asFunction<int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>();

  int scanf1(
    ffi.Pointer<ffi.Char> __format,
  ) {
    return _scanf1(
      __format,
    );
  }

  late final _scanf1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'scanf');
  late final _scanf1 =
      _scanf1Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int sscanf1(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __format,
  ) {
    return _sscanf1(
      __s,
      __format,
    );
  }

  late final _sscanf1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('sscanf');
  late final _sscanf1 = _sscanf1Ptr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int vfscanf(
    ffi.Pointer<FILE> __s,
    ffi.Pointer<ffi.Char> __format,
    ffi.Pointer<__va_list_tag> __arg,
  ) {
    return _vfscanf(
      __s,
      __format,
      __arg,
    );
  }

  late final _vfscanfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<__va_list_tag>)>>('vfscanf');
  late final _vfscanf = _vfscanfPtr.asFunction<
      int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<__va_list_tag>)>();

  int vscanf(
    ffi.Pointer<ffi.Char> __format,
    ffi.Pointer<__va_list_tag> __arg,
  ) {
    return _vscanf(
      __format,
      __arg,
    );
  }

  late final _vscanfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<__va_list_tag>)>>('vscanf');
  late final _vscanf = _vscanfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<__va_list_tag>)>();

  int vsscanf(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __format,
    ffi.Pointer<__va_list_tag> __arg,
  ) {
    return _vsscanf(
      __s,
      __format,
      __arg,
    );
  }

  late final _vsscanfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<__va_list_tag>)>>('vsscanf');
  late final _vsscanf = _vsscanfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<__va_list_tag>)>();

  int vfscanf1(
    ffi.Pointer<FILE> __s,
    ffi.Pointer<ffi.Char> __format,
    ffi.Pointer<__va_list_tag> __arg,
  ) {
    return _vfscanf1(
      __s,
      __format,
      __arg,
    );
  }

  late final _vfscanf1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<__va_list_tag>)>>('vfscanf');
  late final _vfscanf1 = _vfscanf1Ptr.asFunction<
      int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<__va_list_tag>)>();

  int vscanf1(
    ffi.Pointer<ffi.Char> __format,
    ffi.Pointer<__va_list_tag> __arg,
  ) {
    return _vscanf1(
      __format,
      __arg,
    );
  }

  late final _vscanf1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<__va_list_tag>)>>('vscanf');
  late final _vscanf1 = _vscanf1Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<__va_list_tag>)>();

  int vsscanf1(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __format,
    ffi.Pointer<__va_list_tag> __arg,
  ) {
    return _vsscanf1(
      __s,
      __format,
      __arg,
    );
  }

  late final _vsscanf1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<__va_list_tag>)>>('vsscanf');
  late final _vsscanf1 = _vsscanf1Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<__va_list_tag>)>();

  int fgetc(
    ffi.Pointer<FILE> __stream,
  ) {
    return _fgetc(
      __stream,
    );
  }

  late final _fgetcPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>('fgetc');
  late final _fgetc = _fgetcPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int getc(
    ffi.Pointer<FILE> __stream,
  ) {
    return _getc(
      __stream,
    );
  }

  late final _getcPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>('getc');
  late final _getc = _getcPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int getchar() {
    return _getchar();
  }

  late final _getcharPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('getchar');
  late final _getchar = _getcharPtr.asFunction<int Function()>();

  int getc_unlocked(
    ffi.Pointer<FILE> __stream,
  ) {
    return _getc_unlocked(
      __stream,
    );
  }

  late final _getc_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'getc_unlocked');
  late final _getc_unlocked =
      _getc_unlockedPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int getchar_unlocked() {
    return _getchar_unlocked();
  }

  late final _getchar_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('getchar_unlocked');
  late final _getchar_unlocked =
      _getchar_unlockedPtr.asFunction<int Function()>();

  int fgetc_unlocked(
    ffi.Pointer<FILE> __stream,
  ) {
    return _fgetc_unlocked(
      __stream,
    );
  }

  late final _fgetc_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'fgetc_unlocked');
  late final _fgetc_unlocked =
      _fgetc_unlockedPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int fputc(
    int __c,
    ffi.Pointer<FILE> __stream,
  ) {
    return _fputc(
      __c,
      __stream,
    );
  }

  late final _fputcPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          'fputc');
  late final _fputc =
      _fputcPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  int putc(
    int __c,
    ffi.Pointer<FILE> __stream,
  ) {
    return _putc(
      __c,
      __stream,
    );
  }

  late final _putcPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          'putc');
  late final _putc =
      _putcPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  int putchar(
    int __c,
  ) {
    return _putchar(
      __c,
    );
  }

  late final _putcharPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('putchar');
  late final _putchar = _putcharPtr.asFunction<int Function(int)>();

  int fputc_unlocked(
    int __c,
    ffi.Pointer<FILE> __stream,
  ) {
    return _fputc_unlocked(
      __c,
      __stream,
    );
  }

  late final _fputc_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          'fputc_unlocked');
  late final _fputc_unlocked =
      _fputc_unlockedPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  int putc_unlocked(
    int __c,
    ffi.Pointer<FILE> __stream,
  ) {
    return _putc_unlocked(
      __c,
      __stream,
    );
  }

  late final _putc_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          'putc_unlocked');
  late final _putc_unlocked =
      _putc_unlockedPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  int putchar_unlocked(
    int __c,
  ) {
    return _putchar_unlocked(
      __c,
    );
  }

  late final _putchar_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'putchar_unlocked');
  late final _putchar_unlocked =
      _putchar_unlockedPtr.asFunction<int Function(int)>();

  int getw(
    ffi.Pointer<FILE> __stream,
  ) {
    return _getw(
      __stream,
    );
  }

  late final _getwPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>('getw');
  late final _getw = _getwPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int putw(
    int __w,
    ffi.Pointer<FILE> __stream,
  ) {
    return _putw(
      __w,
      __stream,
    );
  }

  late final _putwPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          'putw');
  late final _putw =
      _putwPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  ffi.Pointer<ffi.Char> fgets(
    ffi.Pointer<ffi.Char> __s,
    int __n,
    ffi.Pointer<FILE> __stream,
  ) {
    return _fgets(
      __s,
      __n,
      __stream,
    );
  }

  late final _fgetsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int, ffi.Pointer<FILE>)>>('fgets');
  late final _fgets = _fgetsPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<FILE>)>();

  int __getdelim(
    ffi.Pointer<ffi.Pointer<ffi.Char>> __lineptr,
    ffi.Pointer<ffi.Size> __n,
    int __delimiter,
    ffi.Pointer<FILE> __stream,
  ) {
    return ___getdelim(
      __lineptr,
      __n,
      __delimiter,
      __stream,
    );
  }

  late final ___getdelimPtr = _lookup<
      ffi.NativeFunction<
          __ssize_t Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>,
              ffi.Int,
              ffi.Pointer<FILE>)>>('__getdelim');
  late final ___getdelim = ___getdelimPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Size>,
          int, ffi.Pointer<FILE>)>();

  int getdelim(
    ffi.Pointer<ffi.Pointer<ffi.Char>> __lineptr,
    ffi.Pointer<ffi.Size> __n,
    int __delimiter,
    ffi.Pointer<FILE> __stream,
  ) {
    return _getdelim(
      __lineptr,
      __n,
      __delimiter,
      __stream,
    );
  }

  late final _getdelimPtr = _lookup<
      ffi.NativeFunction<
          __ssize_t Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>, ffi.Int, ffi.Pointer<FILE>)>>('getdelim');
  late final _getdelim = _getdelimPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Size>,
          int, ffi.Pointer<FILE>)>();

  int getline(
    ffi.Pointer<ffi.Pointer<ffi.Char>> __lineptr,
    ffi.Pointer<ffi.Size> __n,
    ffi.Pointer<FILE> __stream,
  ) {
    return _getline(
      __lineptr,
      __n,
      __stream,
    );
  }

  late final _getlinePtr = _lookup<
      ffi.NativeFunction<
          __ssize_t Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>, ffi.Pointer<FILE>)>>('getline');
  late final _getline = _getlinePtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Size>,
          ffi.Pointer<FILE>)>();

  int fputs(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<FILE> __stream,
  ) {
    return _fputs(
      __s,
      __stream,
    );
  }

  late final _fputsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<FILE>)>>('fputs');
  late final _fputs = _fputsPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<FILE>)>();

  int puts(
    ffi.Pointer<ffi.Char> __s,
  ) {
    return _puts(
      __s,
    );
  }

  late final _putsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'puts');
  late final _puts = _putsPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int ungetc(
    int __c,
    ffi.Pointer<FILE> __stream,
  ) {
    return _ungetc(
      __c,
      __stream,
    );
  }

  late final _ungetcPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          'ungetc');
  late final _ungetc =
      _ungetcPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  int fread(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
    int __n,
    ffi.Pointer<FILE> __stream,
  ) {
    return _fread(
      __ptr,
      __size,
      __n,
      __stream,
    );
  }

  late final _freadPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size,
              ffi.Pointer<FILE>)>>('fread');
  late final _fread = _freadPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<FILE>)>();

  int fwrite(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
    int __n,
    ffi.Pointer<FILE> __s,
  ) {
    return _fwrite(
      __ptr,
      __size,
      __n,
      __s,
    );
  }

  late final _fwritePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size,
              ffi.Pointer<FILE>)>>('fwrite');
  late final _fwrite = _fwritePtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<FILE>)>();

  int fread_unlocked(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
    int __n,
    ffi.Pointer<FILE> __stream,
  ) {
    return _fread_unlocked(
      __ptr,
      __size,
      __n,
      __stream,
    );
  }

  late final _fread_unlockedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size,
              ffi.Pointer<FILE>)>>('fread_unlocked');
  late final _fread_unlocked = _fread_unlockedPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<FILE>)>();

  int fwrite_unlocked(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
    int __n,
    ffi.Pointer<FILE> __stream,
  ) {
    return _fwrite_unlocked(
      __ptr,
      __size,
      __n,
      __stream,
    );
  }

  late final _fwrite_unlockedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size,
              ffi.Pointer<FILE>)>>('fwrite_unlocked');
  late final _fwrite_unlocked = _fwrite_unlockedPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<FILE>)>();

  int fseek(
    ffi.Pointer<FILE> __stream,
    int __off,
    int __whence,
  ) {
    return _fseek(
      __stream,
      __off,
      __whence,
    );
  }

  late final _fseekPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, ffi.Long, ffi.Int)>>('fseek');
  late final _fseek =
      _fseekPtr.asFunction<int Function(ffi.Pointer<FILE>, int, int)>();

  int ftell(
    ffi.Pointer<FILE> __stream,
  ) {
    return _ftell(
      __stream,
    );
  }

  late final _ftellPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<FILE>)>>(
          'ftell');
  late final _ftell = _ftellPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  void rewind(
    ffi.Pointer<FILE> __stream,
  ) {
    return _rewind(
      __stream,
    );
  }

  late final _rewindPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FILE>)>>(
          'rewind');
  late final _rewind =
      _rewindPtr.asFunction<void Function(ffi.Pointer<FILE>)>();

  int fseeko(
    ffi.Pointer<FILE> __stream,
    int __off,
    int __whence,
  ) {
    return _fseeko(
      __stream,
      __off,
      __whence,
    );
  }

  late final _fseekoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, __off_t, ffi.Int)>>('fseeko');
  late final _fseeko =
      _fseekoPtr.asFunction<int Function(ffi.Pointer<FILE>, int, int)>();

  int ftello(
    ffi.Pointer<FILE> __stream,
  ) {
    return _ftello(
      __stream,
    );
  }

  late final _ftelloPtr =
      _lookup<ffi.NativeFunction<__off_t Function(ffi.Pointer<FILE>)>>(
          'ftello');
  late final _ftello = _ftelloPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int fgetpos(
    ffi.Pointer<FILE> __stream,
    ffi.Pointer<fpos_t> __pos,
  ) {
    return _fgetpos(
      __stream,
      __pos,
    );
  }

  late final _fgetposPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, ffi.Pointer<fpos_t>)>>('fgetpos');
  late final _fgetpos = _fgetposPtr
      .asFunction<int Function(ffi.Pointer<FILE>, ffi.Pointer<fpos_t>)>();

  int fsetpos(
    ffi.Pointer<FILE> __stream,
    ffi.Pointer<fpos_t> __pos,
  ) {
    return _fsetpos(
      __stream,
      __pos,
    );
  }

  late final _fsetposPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, ffi.Pointer<fpos_t>)>>('fsetpos');
  late final _fsetpos = _fsetposPtr
      .asFunction<int Function(ffi.Pointer<FILE>, ffi.Pointer<fpos_t>)>();

  void clearerr(
    ffi.Pointer<FILE> __stream,
  ) {
    return _clearerr(
      __stream,
    );
  }

  late final _clearerrPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FILE>)>>(
          'clearerr');
  late final _clearerr =
      _clearerrPtr.asFunction<void Function(ffi.Pointer<FILE>)>();

  int feof(
    ffi.Pointer<FILE> __stream,
  ) {
    return _feof(
      __stream,
    );
  }

  late final _feofPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>('feof');
  late final _feof = _feofPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int ferror(
    ffi.Pointer<FILE> __stream,
  ) {
    return _ferror(
      __stream,
    );
  }

  late final _ferrorPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'ferror');
  late final _ferror = _ferrorPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  void clearerr_unlocked(
    ffi.Pointer<FILE> __stream,
  ) {
    return _clearerr_unlocked(
      __stream,
    );
  }

  late final _clearerr_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FILE>)>>(
          'clearerr_unlocked');
  late final _clearerr_unlocked =
      _clearerr_unlockedPtr.asFunction<void Function(ffi.Pointer<FILE>)>();

  int feof_unlocked(
    ffi.Pointer<FILE> __stream,
  ) {
    return _feof_unlocked(
      __stream,
    );
  }

  late final _feof_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'feof_unlocked');
  late final _feof_unlocked =
      _feof_unlockedPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int ferror_unlocked(
    ffi.Pointer<FILE> __stream,
  ) {
    return _ferror_unlocked(
      __stream,
    );
  }

  late final _ferror_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'ferror_unlocked');
  late final _ferror_unlocked =
      _ferror_unlockedPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  void perror(
    ffi.Pointer<ffi.Char> __s,
  ) {
    return _perror(
      __s,
    );
  }

  late final _perrorPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
          'perror');
  late final _perror =
      _perrorPtr.asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  int fileno(
    ffi.Pointer<FILE> __stream,
  ) {
    return _fileno(
      __stream,
    );
  }

  late final _filenoPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'fileno');
  late final _fileno = _filenoPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int fileno_unlocked(
    ffi.Pointer<FILE> __stream,
  ) {
    return _fileno_unlocked(
      __stream,
    );
  }

  late final _fileno_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'fileno_unlocked');
  late final _fileno_unlocked =
      _fileno_unlockedPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int pclose(
    ffi.Pointer<FILE> __stream,
  ) {
    return _pclose(
      __stream,
    );
  }

  late final _pclosePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'pclose');
  late final _pclose = _pclosePtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  ffi.Pointer<FILE> popen(
    ffi.Pointer<ffi.Char> __command,
    ffi.Pointer<ffi.Char> __modes,
  ) {
    return _popen(
      __command,
      __modes,
    );
  }

  late final _popenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('popen');
  late final _popen = _popenPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> ctermid(
    ffi.Pointer<ffi.Char> __s,
  ) {
    return _ctermid(
      __s,
    );
  }

  late final _ctermidPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('ctermid');
  late final _ctermid = _ctermidPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  void flockfile(
    ffi.Pointer<FILE> __stream,
  ) {
    return _flockfile(
      __stream,
    );
  }

  late final _flockfilePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FILE>)>>(
          'flockfile');
  late final _flockfile =
      _flockfilePtr.asFunction<void Function(ffi.Pointer<FILE>)>();

  int ftrylockfile(
    ffi.Pointer<FILE> __stream,
  ) {
    return _ftrylockfile(
      __stream,
    );
  }

  late final _ftrylockfilePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'ftrylockfile');
  late final _ftrylockfile =
      _ftrylockfilePtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  void funlockfile(
    ffi.Pointer<FILE> __stream,
  ) {
    return _funlockfile(
      __stream,
    );
  }

  late final _funlockfilePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FILE>)>>(
          'funlockfile');
  late final _funlockfile =
      _funlockfilePtr.asFunction<void Function(ffi.Pointer<FILE>)>();

  int __uflow(
    ffi.Pointer<FILE> arg0,
  ) {
    return ___uflow(
      arg0,
    );
  }

  late final ___uflowPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          '__uflow');
  late final ___uflow =
      ___uflowPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int __overflow(
    ffi.Pointer<FILE> arg0,
    int arg1,
  ) {
    return ___overflow(
      arg0,
      arg1,
    );
  }

  late final ___overflowPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>, ffi.Int)>>(
          '__overflow');
  late final ___overflow =
      ___overflowPtr.asFunction<int Function(ffi.Pointer<FILE>, int)>();

  int __ctype_get_mb_cur_max() {
    return ___ctype_get_mb_cur_max();
  }

  late final ___ctype_get_mb_cur_maxPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function()>>(
          '__ctype_get_mb_cur_max');
  late final ___ctype_get_mb_cur_max =
      ___ctype_get_mb_cur_maxPtr.asFunction<int Function()>();

  double atof(
    ffi.Pointer<ffi.Char> __nptr,
  ) {
    return _atof(
      __nptr,
    );
  }

  late final _atofPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'atof');
  late final _atof =
      _atofPtr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  int atoi(
    ffi.Pointer<ffi.Char> __nptr,
  ) {
    return _atoi(
      __nptr,
    );
  }

  late final _atoiPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'atoi');
  late final _atoi = _atoiPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int atol(
    ffi.Pointer<ffi.Char> __nptr,
  ) {
    return _atol(
      __nptr,
    );
  }

  late final _atolPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Char>)>>(
          'atol');
  late final _atol = _atolPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int atoll(
    ffi.Pointer<ffi.Char> __nptr,
  ) {
    return _atoll(
      __nptr,
    );
  }

  late final _atollPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.Pointer<ffi.Char>)>>(
          'atoll');
  late final _atoll =
      _atollPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  double strtod(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
  ) {
    return _strtod(
      __nptr,
      __endptr,
    );
  }

  late final _strtodPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('strtod');
  late final _strtod = _strtodPtr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  double strtof(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
  ) {
    return _strtof(
      __nptr,
      __endptr,
    );
  }

  late final _strtofPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('strtof');
  late final _strtof = _strtofPtr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int strtol(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtol(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtol');
  late final _strtol = _strtolPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoul(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoul(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtoulPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoul');
  late final _strtoul = _strtoulPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoq(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoq(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtoqPtr = _lookup<
      ffi.NativeFunction<
          ffi.LongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoq');
  late final _strtoq = _strtoqPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtouq(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtouq(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtouqPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtouq');
  late final _strtouq = _strtouqPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoll(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoll(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtollPtr = _lookup<
      ffi.NativeFunction<
          ffi.LongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoll');
  late final _strtoll = _strtollPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoull(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoull(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtoullPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoull');
  late final _strtoull = _strtoullPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  ffi.Pointer<ffi.Char> l64a(
    int __n,
  ) {
    return _l64a(
      __n,
    );
  }

  late final _l64aPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Long)>>(
          'l64a');
  late final _l64a = _l64aPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  int a64l(
    ffi.Pointer<ffi.Char> __s,
  ) {
    return _a64l(
      __s,
    );
  }

  late final _a64lPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Char>)>>(
          'a64l');
  late final _a64l = _a64lPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int select(
    int __nfds,
    ffi.Pointer<fd_set> __readfds,
    ffi.Pointer<fd_set> __writefds,
    ffi.Pointer<fd_set> __exceptfds,
    ffi.Pointer<timeval> __timeout,
  ) {
    return _select(
      __nfds,
      __readfds,
      __writefds,
      __exceptfds,
      __timeout,
    );
  }

  late final _selectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<fd_set>, ffi.Pointer<fd_set>,
              ffi.Pointer<fd_set>, ffi.Pointer<timeval>)>>('select');
  late final _select = _selectPtr.asFunction<
      int Function(int, ffi.Pointer<fd_set>, ffi.Pointer<fd_set>,
          ffi.Pointer<fd_set>, ffi.Pointer<timeval>)>();

  int pselect(
    int __nfds,
    ffi.Pointer<fd_set> __readfds,
    ffi.Pointer<fd_set> __writefds,
    ffi.Pointer<fd_set> __exceptfds,
    ffi.Pointer<timespec> __timeout,
    ffi.Pointer<__sigset_t> __sigmask,
  ) {
    return _pselect(
      __nfds,
      __readfds,
      __writefds,
      __exceptfds,
      __timeout,
      __sigmask,
    );
  }

  late final _pselectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int,
              ffi.Pointer<fd_set>,
              ffi.Pointer<fd_set>,
              ffi.Pointer<fd_set>,
              ffi.Pointer<timespec>,
              ffi.Pointer<__sigset_t>)>>('pselect');
  late final _pselect = _pselectPtr.asFunction<
      int Function(
          int,
          ffi.Pointer<fd_set>,
          ffi.Pointer<fd_set>,
          ffi.Pointer<fd_set>,
          ffi.Pointer<timespec>,
          ffi.Pointer<__sigset_t>)>();

  int random() {
    return _random();
  }

  late final _randomPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function()>>('random');
  late final _random = _randomPtr.asFunction<int Function()>();

  void srandom(
    int __seed,
  ) {
    return _srandom(
      __seed,
    );
  }

  late final _srandomPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>(
          'srandom');
  late final _srandom = _srandomPtr.asFunction<void Function(int)>();

  ffi.Pointer<ffi.Char> initstate(
    int __seed,
    ffi.Pointer<ffi.Char> __statebuf,
    int __statelen,
  ) {
    return _initstate(
      __seed,
      __statebuf,
      __statelen,
    );
  }

  late final _initstatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Size)>>('initstate');
  late final _initstate = _initstatePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> setstate(
    ffi.Pointer<ffi.Char> __statebuf,
  ) {
    return _setstate(
      __statebuf,
    );
  }

  late final _setstatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('setstate');
  late final _setstate = _setstatePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int random_r(
    ffi.Pointer<random_data> __buf,
    ffi.Pointer<ffi.Int32> __result,
  ) {
    return _random_r(
      __buf,
      __result,
    );
  }

  late final _random_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<random_data>, ffi.Pointer<ffi.Int32>)>>('random_r');
  late final _random_r = _random_rPtr.asFunction<
      int Function(ffi.Pointer<random_data>, ffi.Pointer<ffi.Int32>)>();

  int srandom_r(
    int __seed,
    ffi.Pointer<random_data> __buf,
  ) {
    return _srandom_r(
      __seed,
      __buf,
    );
  }

  late final _srandom_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.UnsignedInt, ffi.Pointer<random_data>)>>('srandom_r');
  late final _srandom_r =
      _srandom_rPtr.asFunction<int Function(int, ffi.Pointer<random_data>)>();

  int initstate_r(
    int __seed,
    ffi.Pointer<ffi.Char> __statebuf,
    int __statelen,
    ffi.Pointer<random_data> __buf,
  ) {
    return _initstate_r(
      __seed,
      __statebuf,
      __statelen,
      __buf,
    );
  }

  late final _initstate_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<random_data>)>>('initstate_r');
  late final _initstate_r = _initstate_rPtr.asFunction<
      int Function(
          int, ffi.Pointer<ffi.Char>, int, ffi.Pointer<random_data>)>();

  int setstate_r(
    ffi.Pointer<ffi.Char> __statebuf,
    ffi.Pointer<random_data> __buf,
  ) {
    return _setstate_r(
      __statebuf,
      __buf,
    );
  }

  late final _setstate_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<random_data>)>>('setstate_r');
  late final _setstate_r = _setstate_rPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<random_data>)>();

  int rand() {
    return _rand();
  }

  late final _randPtr = _lookup<ffi.NativeFunction<ffi.Int Function()>>('rand');
  late final _rand = _randPtr.asFunction<int Function()>();

  void srand(
    int __seed,
  ) {
    return _srand(
      __seed,
    );
  }

  late final _srandPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>('srand');
  late final _srand = _srandPtr.asFunction<void Function(int)>();

  int rand_r(
    ffi.Pointer<ffi.UnsignedInt> __seed,
  ) {
    return _rand_r(
      __seed,
    );
  }

  late final _rand_rPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.UnsignedInt>)>>(
      'rand_r');
  late final _rand_r =
      _rand_rPtr.asFunction<int Function(ffi.Pointer<ffi.UnsignedInt>)>();

  double drand48() {
    return _drand48();
  }

  late final _drand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function()>>('drand48');
  late final _drand48 = _drand48Ptr.asFunction<double Function()>();

  double erand48(
    ffi.Pointer<ffi.UnsignedShort> __xsubi,
  ) {
    return _erand48(
      __xsubi,
    );
  }

  late final _erand48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.UnsignedShort>)>>('erand48');
  late final _erand48 =
      _erand48Ptr.asFunction<double Function(ffi.Pointer<ffi.UnsignedShort>)>();

  int lrand48() {
    return _lrand48();
  }

  late final _lrand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function()>>('lrand48');
  late final _lrand48 = _lrand48Ptr.asFunction<int Function()>();

  int nrand48(
    ffi.Pointer<ffi.UnsignedShort> __xsubi,
  ) {
    return _nrand48(
      __xsubi,
    );
  }

  late final _nrand48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.UnsignedShort>)>>('nrand48');
  late final _nrand48 =
      _nrand48Ptr.asFunction<int Function(ffi.Pointer<ffi.UnsignedShort>)>();

  int mrand48() {
    return _mrand48();
  }

  late final _mrand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function()>>('mrand48');
  late final _mrand48 = _mrand48Ptr.asFunction<int Function()>();

  int jrand48(
    ffi.Pointer<ffi.UnsignedShort> __xsubi,
  ) {
    return _jrand48(
      __xsubi,
    );
  }

  late final _jrand48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.UnsignedShort>)>>('jrand48');
  late final _jrand48 =
      _jrand48Ptr.asFunction<int Function(ffi.Pointer<ffi.UnsignedShort>)>();

  void srand48(
    int __seedval,
  ) {
    return _srand48(
      __seedval,
    );
  }

  late final _srand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Long)>>('srand48');
  late final _srand48 = _srand48Ptr.asFunction<void Function(int)>();

  ffi.Pointer<ffi.UnsignedShort> seed48(
    ffi.Pointer<ffi.UnsignedShort> __seed16v,
  ) {
    return _seed48(
      __seed16v,
    );
  }

  late final _seed48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.UnsignedShort> Function(
              ffi.Pointer<ffi.UnsignedShort>)>>('seed48');
  late final _seed48 = _seed48Ptr.asFunction<
      ffi.Pointer<ffi.UnsignedShort> Function(
          ffi.Pointer<ffi.UnsignedShort>)>();

  void lcong48(
    ffi.Pointer<ffi.UnsignedShort> __param,
  ) {
    return _lcong48(
      __param,
    );
  }

  late final _lcong48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.UnsignedShort>)>>('lcong48');
  late final _lcong48 =
      _lcong48Ptr.asFunction<void Function(ffi.Pointer<ffi.UnsignedShort>)>();

  int drand48_r(
    ffi.Pointer<drand48_data> __buffer,
    ffi.Pointer<ffi.Double> __result,
  ) {
    return _drand48_r(
      __buffer,
      __result,
    );
  }

  late final _drand48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<drand48_data>,
              ffi.Pointer<ffi.Double>)>>('drand48_r');
  late final _drand48_r = _drand48_rPtr.asFunction<
      int Function(ffi.Pointer<drand48_data>, ffi.Pointer<ffi.Double>)>();

  int erand48_r(
    ffi.Pointer<ffi.UnsignedShort> __xsubi,
    ffi.Pointer<drand48_data> __buffer,
    ffi.Pointer<ffi.Double> __result,
  ) {
    return _erand48_r(
      __xsubi,
      __buffer,
      __result,
    );
  }

  late final _erand48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.UnsignedShort>,
              ffi.Pointer<drand48_data>,
              ffi.Pointer<ffi.Double>)>>('erand48_r');
  late final _erand48_r = _erand48_rPtr.asFunction<
      int Function(ffi.Pointer<ffi.UnsignedShort>, ffi.Pointer<drand48_data>,
          ffi.Pointer<ffi.Double>)>();

  int lrand48_r(
    ffi.Pointer<drand48_data> __buffer,
    ffi.Pointer<ffi.Long> __result,
  ) {
    return _lrand48_r(
      __buffer,
      __result,
    );
  }

  late final _lrand48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<drand48_data>, ffi.Pointer<ffi.Long>)>>('lrand48_r');
  late final _lrand48_r = _lrand48_rPtr.asFunction<
      int Function(ffi.Pointer<drand48_data>, ffi.Pointer<ffi.Long>)>();

  int nrand48_r(
    ffi.Pointer<ffi.UnsignedShort> __xsubi,
    ffi.Pointer<drand48_data> __buffer,
    ffi.Pointer<ffi.Long> __result,
  ) {
    return _nrand48_r(
      __xsubi,
      __buffer,
      __result,
    );
  }

  late final _nrand48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedShort>,
              ffi.Pointer<drand48_data>, ffi.Pointer<ffi.Long>)>>('nrand48_r');
  late final _nrand48_r = _nrand48_rPtr.asFunction<
      int Function(ffi.Pointer<ffi.UnsignedShort>, ffi.Pointer<drand48_data>,
          ffi.Pointer<ffi.Long>)>();

  int mrand48_r(
    ffi.Pointer<drand48_data> __buffer,
    ffi.Pointer<ffi.Long> __result,
  ) {
    return _mrand48_r(
      __buffer,
      __result,
    );
  }

  late final _mrand48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<drand48_data>, ffi.Pointer<ffi.Long>)>>('mrand48_r');
  late final _mrand48_r = _mrand48_rPtr.asFunction<
      int Function(ffi.Pointer<drand48_data>, ffi.Pointer<ffi.Long>)>();

  int jrand48_r(
    ffi.Pointer<ffi.UnsignedShort> __xsubi,
    ffi.Pointer<drand48_data> __buffer,
    ffi.Pointer<ffi.Long> __result,
  ) {
    return _jrand48_r(
      __xsubi,
      __buffer,
      __result,
    );
  }

  late final _jrand48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedShort>,
              ffi.Pointer<drand48_data>, ffi.Pointer<ffi.Long>)>>('jrand48_r');
  late final _jrand48_r = _jrand48_rPtr.asFunction<
      int Function(ffi.Pointer<ffi.UnsignedShort>, ffi.Pointer<drand48_data>,
          ffi.Pointer<ffi.Long>)>();

  int srand48_r(
    int __seedval,
    ffi.Pointer<drand48_data> __buffer,
  ) {
    return _srand48_r(
      __seedval,
      __buffer,
    );
  }

  late final _srand48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Long, ffi.Pointer<drand48_data>)>>('srand48_r');
  late final _srand48_r =
      _srand48_rPtr.asFunction<int Function(int, ffi.Pointer<drand48_data>)>();

  int seed48_r(
    ffi.Pointer<ffi.UnsignedShort> __seed16v,
    ffi.Pointer<drand48_data> __buffer,
  ) {
    return _seed48_r(
      __seed16v,
      __buffer,
    );
  }

  late final _seed48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedShort>,
              ffi.Pointer<drand48_data>)>>('seed48_r');
  late final _seed48_r = _seed48_rPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.UnsignedShort>, ffi.Pointer<drand48_data>)>();

  int lcong48_r(
    ffi.Pointer<ffi.UnsignedShort> __param,
    ffi.Pointer<drand48_data> __buffer,
  ) {
    return _lcong48_r(
      __param,
      __buffer,
    );
  }

  late final _lcong48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedShort>,
              ffi.Pointer<drand48_data>)>>('lcong48_r');
  late final _lcong48_r = _lcong48_rPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.UnsignedShort>, ffi.Pointer<drand48_data>)>();

  int arc4random() {
    return _arc4random();
  }

  late final _arc4randomPtr =
      _lookup<ffi.NativeFunction<__uint32_t Function()>>('arc4random');
  late final _arc4random = _arc4randomPtr.asFunction<int Function()>();

  void arc4random_buf(
    ffi.Pointer<ffi.Void> __buf,
    int __size,
  ) {
    return _arc4random_buf(
      __buf,
      __size,
    );
  }

  late final _arc4random_bufPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('arc4random_buf');
  late final _arc4random_buf = _arc4random_bufPtr
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  int arc4random_uniform(
    int __upper_bound,
  ) {
    return _arc4random_uniform(
      __upper_bound,
    );
  }

  late final _arc4random_uniformPtr =
      _lookup<ffi.NativeFunction<__uint32_t Function(__uint32_t)>>(
          'arc4random_uniform');
  late final _arc4random_uniform =
      _arc4random_uniformPtr.asFunction<int Function(int)>();

  ffi.Pointer<ffi.Void> malloc(
    int __size,
  ) {
    return _malloc(
      __size,
    );
  }

  late final _mallocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'malloc');
  late final _malloc =
      _mallocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> calloc(
    int __nmemb,
    int __size,
  ) {
    return _calloc(
      __nmemb,
      __size,
    );
  }

  late final _callocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('calloc');
  late final _calloc =
      _callocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> realloc(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
  ) {
    return _realloc(
      __ptr,
      __size,
    );
  }

  late final _reallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('realloc');
  late final _realloc = _reallocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  void free(
    ffi.Pointer<ffi.Void> __ptr,
  ) {
    return _free(
      __ptr,
    );
  }

  late final _freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'free');
  late final _free =
      _freePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> reallocarray(
    ffi.Pointer<ffi.Void> __ptr,
    int __nmemb,
    int __size,
  ) {
    return _reallocarray(
      __ptr,
      __nmemb,
      __size,
    );
  }

  late final _reallocarrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size)>>('reallocarray');
  late final _reallocarray = _reallocarrayPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> reallocarray1(
    ffi.Pointer<ffi.Void> __ptr,
    int __nmemb,
    int __size,
  ) {
    return _reallocarray1(
      __ptr,
      __nmemb,
      __size,
    );
  }

  late final _reallocarray1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size)>>('reallocarray');
  late final _reallocarray1 = _reallocarray1Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> alloca(
    int __size,
  ) {
    return _alloca(
      __size,
    );
  }

  late final _allocaPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'alloca');
  late final _alloca =
      _allocaPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> valloc(
    int __size,
  ) {
    return _valloc(
      __size,
    );
  }

  late final _vallocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'valloc');
  late final _valloc =
      _vallocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  int posix_memalign(
    ffi.Pointer<ffi.Pointer<ffi.Void>> __memptr,
    int __alignment,
    int __size,
  ) {
    return _posix_memalign(
      __memptr,
      __alignment,
      __size,
    );
  }

  late final _posix_memalignPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Size,
              ffi.Size)>>('posix_memalign');
  late final _posix_memalign = _posix_memalignPtr
      .asFunction<int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, int, int)>();

  ffi.Pointer<ffi.Void> aligned_alloc(
    int __alignment,
    int __size,
  ) {
    return _aligned_alloc(
      __alignment,
      __size,
    );
  }

  late final _aligned_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('aligned_alloc');
  late final _aligned_alloc =
      _aligned_allocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  void abort() {
    return _abort();
  }

  late final _abortPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('abort');
  late final _abort = _abortPtr.asFunction<void Function()>();

  int atexit(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> __func,
  ) {
    return _atexit(
      __func,
    );
  }

  late final _atexitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>>('atexit');
  late final _atexit = _atexitPtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>();

  int at_quick_exit(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> __func,
  ) {
    return _at_quick_exit(
      __func,
    );
  }

  late final _at_quick_exitPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>>(
      'at_quick_exit');
  late final _at_quick_exit = _at_quick_exitPtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>();

  int on_exit(
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Int, ffi.Pointer<ffi.Void>)>>
        __func,
    ffi.Pointer<ffi.Void> __arg,
  ) {
    return _on_exit(
      __func,
      __arg,
    );
  }

  late final _on_exitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Int, ffi.Pointer<ffi.Void>)>>,
              ffi.Pointer<ffi.Void>)>>('on_exit');
  late final _on_exit = _on_exitPtr.asFunction<
      int Function(
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Int, ffi.Pointer<ffi.Void>)>>,
          ffi.Pointer<ffi.Void>)>();

  void exit(
    int __status,
  ) {
    return _exit(
      __status,
    );
  }

  late final _exitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('exit');
  late final _exit = _exitPtr.asFunction<void Function(int)>();

  void quick_exit(
    int __status,
  ) {
    return _quick_exit(
      __status,
    );
  }

  late final _quick_exitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('quick_exit');
  late final _quick_exit = _quick_exitPtr.asFunction<void Function(int)>();

  void _Exit(
    int __status,
  ) {
    return __Exit(
      __status,
    );
  }

  late final __ExitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('_Exit');
  late final __Exit = __ExitPtr.asFunction<void Function(int)>();

  ffi.Pointer<ffi.Char> getenv(
    ffi.Pointer<ffi.Char> __name,
  ) {
    return _getenv(
      __name,
    );
  }

  late final _getenvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('getenv');
  late final _getenv = _getenvPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int putenv(
    ffi.Pointer<ffi.Char> __string,
  ) {
    return _putenv(
      __string,
    );
  }

  late final _putenvPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'putenv');
  late final _putenv =
      _putenvPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int setenv(
    ffi.Pointer<ffi.Char> __name,
    ffi.Pointer<ffi.Char> __value,
    int __replace,
  ) {
    return _setenv(
      __name,
      __value,
      __replace,
    );
  }

  late final _setenvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('setenv');
  late final _setenv = _setenvPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int unsetenv(
    ffi.Pointer<ffi.Char> __name,
  ) {
    return _unsetenv(
      __name,
    );
  }

  late final _unsetenvPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'unsetenv');
  late final _unsetenv =
      _unsetenvPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int clearenv() {
    return _clearenv();
  }

  late final _clearenvPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('clearenv');
  late final _clearenv = _clearenvPtr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> mktemp(
    ffi.Pointer<ffi.Char> __template,
  ) {
    return _mktemp(
      __template,
    );
  }

  late final _mktempPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('mktemp');
  late final _mktemp = _mktempPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int mkstemp(
    ffi.Pointer<ffi.Char> __template,
  ) {
    return _mkstemp(
      __template,
    );
  }

  late final _mkstempPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'mkstemp');
  late final _mkstemp =
      _mkstempPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int mkstemps(
    ffi.Pointer<ffi.Char> __template,
    int __suffixlen,
  ) {
    return _mkstemps(
      __template,
      __suffixlen,
    );
  }

  late final _mkstempsPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int)>>(
      'mkstemps');
  late final _mkstemps =
      _mkstempsPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> mkdtemp(
    ffi.Pointer<ffi.Char> __template,
  ) {
    return _mkdtemp(
      __template,
    );
  }

  late final _mkdtempPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('mkdtemp');
  late final _mkdtemp = _mkdtempPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int system(
    ffi.Pointer<ffi.Char> __command,
  ) {
    return _system(
      __command,
    );
  }

  late final _systemPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'system');
  late final _system =
      _systemPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> realpath(
    ffi.Pointer<ffi.Char> __name,
    ffi.Pointer<ffi.Char> __resolved,
  ) {
    return _realpath(
      __name,
      __resolved,
    );
  }

  late final _realpathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('realpath');
  late final _realpath = _realpathPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Void> bsearch(
    ffi.Pointer<ffi.Void> __key,
    ffi.Pointer<ffi.Void> __base,
    int __nmemb,
    int __size,
    __compar_fn_t __compar,
  ) {
    return _bsearch(
      __key,
      __base,
      __nmemb,
      __size,
      __compar,
    );
  }

  late final _bsearchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              __compar_fn_t)>>('bsearch');
  late final _bsearch = _bsearchPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>, int, int, __compar_fn_t)>();

  void qsort(
    ffi.Pointer<ffi.Void> __base,
    int __nmemb,
    int __size,
    __compar_fn_t __compar,
  ) {
    return _qsort(
      __base,
      __nmemb,
      __size,
      __compar,
    );
  }

  late final _qsortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size,
              __compar_fn_t)>>('qsort');
  late final _qsort = _qsortPtr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, int, int, __compar_fn_t)>();

  int abs(
    int __x,
  ) {
    return _abs(
      __x,
    );
  }

  late final _absPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('abs');
  late final _abs = _absPtr.asFunction<int Function(int)>();

  int labs(
    int __x,
  ) {
    return _labs(
      __x,
    );
  }

  late final _labsPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Long)>>('labs');
  late final _labs = _labsPtr.asFunction<int Function(int)>();

  int llabs(
    int __x,
  ) {
    return _llabs(
      __x,
    );
  }

  late final _llabsPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.LongLong)>>('llabs');
  late final _llabs = _llabsPtr.asFunction<int Function(int)>();

  div_t div(
    int __numer,
    int __denom,
  ) {
    return _div(
      __numer,
      __denom,
    );
  }

  late final _divPtr =
      _lookup<ffi.NativeFunction<div_t Function(ffi.Int, ffi.Int)>>('div');
  late final _div = _divPtr.asFunction<div_t Function(int, int)>();

  ldiv_t ldiv(
    int __numer,
    int __denom,
  ) {
    return _ldiv(
      __numer,
      __denom,
    );
  }

  late final _ldivPtr =
      _lookup<ffi.NativeFunction<ldiv_t Function(ffi.Long, ffi.Long)>>('ldiv');
  late final _ldiv = _ldivPtr.asFunction<ldiv_t Function(int, int)>();

  lldiv_t lldiv(
    int __numer,
    int __denom,
  ) {
    return _lldiv(
      __numer,
      __denom,
    );
  }

  late final _lldivPtr =
      _lookup<ffi.NativeFunction<lldiv_t Function(ffi.LongLong, ffi.LongLong)>>(
          'lldiv');
  late final _lldiv = _lldivPtr.asFunction<lldiv_t Function(int, int)>();

  ffi.Pointer<ffi.Char> ecvt(
    double __value,
    int __ndigit,
    ffi.Pointer<ffi.Int> __decpt,
    ffi.Pointer<ffi.Int> __sign,
  ) {
    return _ecvt(
      __value,
      __ndigit,
      __decpt,
      __sign,
    );
  }

  late final _ecvtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Double, ffi.Int,
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>>('ecvt');
  late final _ecvt = _ecvtPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          double, int, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  ffi.Pointer<ffi.Char> fcvt(
    double __value,
    int __ndigit,
    ffi.Pointer<ffi.Int> __decpt,
    ffi.Pointer<ffi.Int> __sign,
  ) {
    return _fcvt(
      __value,
      __ndigit,
      __decpt,
      __sign,
    );
  }

  late final _fcvtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Double, ffi.Int,
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>>('fcvt');
  late final _fcvt = _fcvtPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          double, int, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  ffi.Pointer<ffi.Char> gcvt(
    double __value,
    int __ndigit,
    ffi.Pointer<ffi.Char> __buf,
  ) {
    return _gcvt(
      __value,
      __ndigit,
      __buf,
    );
  }

  late final _gcvtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Double, ffi.Int, ffi.Pointer<ffi.Char>)>>('gcvt');
  late final _gcvt = _gcvtPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(double, int, ffi.Pointer<ffi.Char>)>();

  int ecvt_r(
    double __value,
    int __ndigit,
    ffi.Pointer<ffi.Int> __decpt,
    ffi.Pointer<ffi.Int> __sign,
    ffi.Pointer<ffi.Char> __buf,
    int __len,
  ) {
    return _ecvt_r(
      __value,
      __ndigit,
      __decpt,
      __sign,
      __buf,
      __len,
    );
  }

  late final _ecvt_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Double,
              ffi.Int,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('ecvt_r');
  late final _ecvt_r = _ecvt_rPtr.asFunction<
      int Function(double, int, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Char>, int)>();

  int fcvt_r(
    double __value,
    int __ndigit,
    ffi.Pointer<ffi.Int> __decpt,
    ffi.Pointer<ffi.Int> __sign,
    ffi.Pointer<ffi.Char> __buf,
    int __len,
  ) {
    return _fcvt_r(
      __value,
      __ndigit,
      __decpt,
      __sign,
      __buf,
      __len,
    );
  }

  late final _fcvt_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Double,
              ffi.Int,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('fcvt_r');
  late final _fcvt_r = _fcvt_rPtr.asFunction<
      int Function(double, int, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Char>, int)>();

  int mblen(
    ffi.Pointer<ffi.Char> __s,
    int __n,
  ) {
    return _mblen(
      __s,
      __n,
    );
  }

  late final _mblenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size)>>('mblen');
  late final _mblen =
      _mblenPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int mbtowc(
    ffi.Pointer<ffi.WChar> __pwc,
    ffi.Pointer<ffi.Char> __s,
    int __n,
  ) {
    return _mbtowc(
      __pwc,
      __s,
      __n,
    );
  }

  late final _mbtowcPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('mbtowc');
  late final _mbtowc = _mbtowcPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>, int)>();

  int wctomb(
    ffi.Pointer<ffi.Char> __s,
    int __wchar,
  ) {
    return _wctomb(
      __s,
      __wchar,
    );
  }

  late final _wctombPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.WChar)>>('wctomb');
  late final _wctomb =
      _wctombPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int mbstowcs(
    ffi.Pointer<ffi.WChar> __pwcs,
    ffi.Pointer<ffi.Char> __s,
    int __n,
  ) {
    return _mbstowcs(
      __pwcs,
      __s,
      __n,
    );
  }

  late final _mbstowcsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('mbstowcs');
  late final _mbstowcs = _mbstowcsPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>, int)>();

  int wcstombs(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.WChar> __pwcs,
    int __n,
  ) {
    return _wcstombs(
      __s,
      __pwcs,
      __n,
    );
  }

  late final _wcstombsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('wcstombs');
  late final _wcstombs = _wcstombsPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.WChar>, int)>();

  int rpmatch(
    ffi.Pointer<ffi.Char> __response,
  ) {
    return _rpmatch(
      __response,
    );
  }

  late final _rpmatchPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'rpmatch');
  late final _rpmatch =
      _rpmatchPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int getsubopt(
    ffi.Pointer<ffi.Pointer<ffi.Char>> __optionp,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __tokens,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __valuep,
  ) {
    return _getsubopt(
      __optionp,
      __tokens,
      __valuep,
    );
  }

  late final _getsuboptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('getsubopt');
  late final _getsubopt = _getsuboptPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int getloadavg(
    ffi.Pointer<ffi.Double> __loadavg,
    int __nelem,
  ) {
    return _getloadavg(
      __loadavg,
      __nelem,
    );
  }

  late final _getloadavgPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Double>, ffi.Int)>>('getloadavg');
  late final _getloadavg =
      _getloadavgPtr.asFunction<int Function(ffi.Pointer<ffi.Double>, int)>();

  int setjmp(
    ffi.Pointer<__jmp_buf_tag> __env,
  ) {
    return _setjmp1(
      __env,
    );
  }

  late final _setjmpPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<__jmp_buf_tag>)>>(
          'setjmp');
  late final _setjmp1 =
      _setjmpPtr.asFunction<int Function(ffi.Pointer<__jmp_buf_tag>)>();

  int __sigsetjmp(
    ffi.Pointer<__jmp_buf_tag> __env,
    int __savemask,
  ) {
    return ___sigsetjmp(
      __env,
      __savemask,
    );
  }

  late final ___sigsetjmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<__jmp_buf_tag>, ffi.Int)>>('__sigsetjmp');
  late final ___sigsetjmp = ___sigsetjmpPtr
      .asFunction<int Function(ffi.Pointer<__jmp_buf_tag>, int)>();

  int _setjmp(
    ffi.Pointer<__jmp_buf_tag> __env,
  ) {
    return __setjmp(
      __env,
    );
  }

  late final __setjmpPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<__jmp_buf_tag>)>>(
          '_setjmp');
  late final __setjmp =
      __setjmpPtr.asFunction<int Function(ffi.Pointer<__jmp_buf_tag>)>();

  void longjmp(
    ffi.Pointer<__jmp_buf_tag> __env,
    int __val,
  ) {
    return _longjmp1(
      __env,
      __val,
    );
  }

  late final _longjmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<__jmp_buf_tag>, ffi.Int)>>('longjmp');
  late final _longjmp1 =
      _longjmpPtr.asFunction<void Function(ffi.Pointer<__jmp_buf_tag>, int)>();

  void _longjmp(
    ffi.Pointer<__jmp_buf_tag> __env,
    int __val,
  ) {
    return __longjmp(
      __env,
      __val,
    );
  }

  late final __longjmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<__jmp_buf_tag>, ffi.Int)>>('_longjmp');
  late final __longjmp =
      __longjmpPtr.asFunction<void Function(ffi.Pointer<__jmp_buf_tag>, int)>();

  void siglongjmp(
    ffi.Pointer<__jmp_buf_tag> __env,
    int __val,
  ) {
    return _siglongjmp(
      __env,
      __val,
    );
  }

  late final _siglongjmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<__jmp_buf_tag>, ffi.Int)>>('siglongjmp');
  late final _siglongjmp = _siglongjmpPtr
      .asFunction<void Function(ffi.Pointer<__jmp_buf_tag>, int)>();

  /// @function:
  /// FT_Error_String
  ///
  /// @description:
  /// Retrieve the description of a valid FreeType error code.
  ///
  /// @input:
  /// error_code ::
  /// A valid FreeType error code.
  ///
  /// @return:
  /// A C~string or `NULL`, if any error occurred.
  ///
  /// @note:
  /// FreeType has to be compiled with `FT_CONFIG_OPTION_ERROR_STRINGS` or
  /// `FT_DEBUG_LEVEL_ERROR` to get meaningful descriptions.
  /// 'error_string' will be `NULL` otherwise.
  ///
  /// Module identification will be ignored:
  ///
  /// ```c
  /// strcmp( FT_Error_String(  FT_Err_Unknown_File_Format ),
  /// FT_Error_String( BDF_Err_Unknown_File_Format ) ) == 0;
  /// ```
  ffi.Pointer<ffi.Char> FT_Error_String(
    int error_code,
  ) {
    return _FT_Error_String(
      error_code,
    );
  }

  late final _FT_Error_StringPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(FT_Error)>>(
          'FT_Error_String');
  late final _FT_Error_String =
      _FT_Error_StringPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// @function:
  /// FT_Init_FreeType
  ///
  /// @description:
  /// Initialize a new FreeType library object.  The set of modules that are
  /// registered by this function is determined at build time.
  ///
  /// @output:
  /// alibrary ::
  /// A handle to a new library object.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// In case you want to provide your own memory allocating routines, use
  /// @FT_New_Library instead, followed by a call to @FT_Add_Default_Modules
  /// (or a series of calls to @FT_Add_Module) and
  /// @FT_Set_Default_Properties.
  ///
  /// See the documentation of @FT_Library and @FT_Face for multi-threading
  /// issues.
  ///
  /// If you need reference-counting (cf. @FT_Reference_Library), use
  /// @FT_New_Library and @FT_Done_Library.
  ///
  /// If compilation option `FT_CONFIG_OPTION_ENVIRONMENT_PROPERTIES` is
  /// set, this function reads the `FREETYPE_PROPERTIES` environment
  /// variable to control driver properties.  See section @properties for
  /// more.
  int FT_Init_FreeType(
    ffi.Pointer<FT_Library> alibrary,
  ) {
    return _FT_Init_FreeType(
      alibrary,
    );
  }

  late final _FT_Init_FreeTypePtr =
      _lookup<ffi.NativeFunction<FT_Error Function(ffi.Pointer<FT_Library>)>>(
          'FT_Init_FreeType');
  late final _FT_Init_FreeType =
      _FT_Init_FreeTypePtr.asFunction<int Function(ffi.Pointer<FT_Library>)>();

  /// @function:
  /// FT_Done_FreeType
  ///
  /// @description:
  /// Destroy a given FreeType library object and all of its children,
  /// including resources, drivers, faces, sizes, etc.
  ///
  /// @input:
  /// library ::
  /// A handle to the target library object.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  int FT_Done_FreeType(
    FT_Library library1,
  ) {
    return _FT_Done_FreeType(
      library1,
    );
  }

  late final _FT_Done_FreeTypePtr =
      _lookup<ffi.NativeFunction<FT_Error Function(FT_Library)>>(
          'FT_Done_FreeType');
  late final _FT_Done_FreeType =
      _FT_Done_FreeTypePtr.asFunction<int Function(FT_Library)>();

  /// @function:
  /// FT_New_Face
  ///
  /// @description:
  /// Call @FT_Open_Face to open a font by its pathname.
  ///
  /// @inout:
  /// library ::
  /// A handle to the library resource.
  ///
  /// @input:
  /// pathname ::
  /// A path to the font file.
  ///
  /// face_index ::
  /// See @FT_Open_Face for a detailed description of this parameter.
  ///
  /// @output:
  /// aface ::
  /// A handle to a new face object.  If `face_index` is greater than or
  /// equal to zero, it must be non-`NULL`.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// The `pathname` string should be recognizable as such by a standard
  /// `fopen` call on your system; in particular, this means that `pathname`
  /// must not contain null bytes.  If that is not sufficient to address all
  /// file name possibilities (for example, to handle wide character file
  /// names on Windows in UTF-16 encoding) you might use @FT_Open_Face to
  /// pass a memory array or a stream object instead.
  ///
  /// Use @FT_Done_Face to destroy the created @FT_Face object (along with
  /// its slot and sizes).
  int FT_New_Face(
    FT_Library library1,
    ffi.Pointer<ffi.Char> filepathname,
    int face_index,
    ffi.Pointer<FT_Face> aface,
  ) {
    return _FT_New_Face(
      library1,
      filepathname,
      face_index,
      aface,
    );
  }

  late final _FT_New_FacePtr = _lookup<
      ffi.NativeFunction<
          FT_Error Function(FT_Library, ffi.Pointer<ffi.Char>, FT_Long,
              ffi.Pointer<FT_Face>)>>('FT_New_Face');
  late final _FT_New_Face = _FT_New_FacePtr.asFunction<
      int Function(
          FT_Library, ffi.Pointer<ffi.Char>, int, ffi.Pointer<FT_Face>)>();

  /// @function:
  /// FT_New_Memory_Face
  ///
  /// @description:
  /// Call @FT_Open_Face to open a font that has been loaded into memory.
  ///
  /// @inout:
  /// library ::
  /// A handle to the library resource.
  ///
  /// @input:
  /// file_base ::
  /// A pointer to the beginning of the font data.
  ///
  /// file_size ::
  /// The size of the memory chunk used by the font data.
  ///
  /// face_index ::
  /// See @FT_Open_Face for a detailed description of this parameter.
  ///
  /// @output:
  /// aface ::
  /// A handle to a new face object.  If `face_index` is greater than or
  /// equal to zero, it must be non-`NULL`.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// You must not deallocate the memory before calling @FT_Done_Face.
  int FT_New_Memory_Face(
    FT_Library library1,
    ffi.Pointer<FT_Byte> file_base,
    int file_size,
    int face_index,
    ffi.Pointer<FT_Face> aface,
  ) {
    return _FT_New_Memory_Face(
      library1,
      file_base,
      file_size,
      face_index,
      aface,
    );
  }

  late final _FT_New_Memory_FacePtr = _lookup<
      ffi.NativeFunction<
          FT_Error Function(FT_Library, ffi.Pointer<FT_Byte>, FT_Long, FT_Long,
              ffi.Pointer<FT_Face>)>>('FT_New_Memory_Face');
  late final _FT_New_Memory_Face = _FT_New_Memory_FacePtr.asFunction<
      int Function(
          FT_Library, ffi.Pointer<FT_Byte>, int, int, ffi.Pointer<FT_Face>)>();

  /// @function:
  /// FT_Open_Face
  ///
  /// @description:
  /// Create a face object from a given resource described by @FT_Open_Args.
  ///
  /// @inout:
  /// library ::
  /// A handle to the library resource.
  ///
  /// @input:
  /// args ::
  /// A pointer to an `FT_Open_Args` structure that must be filled by the
  /// caller.
  ///
  /// face_index ::
  /// This field holds two different values.  Bits 0-15 are the index of
  /// the face in the font file (starting with value~0).  Set it to~0 if
  /// there is only one face in the font file.
  ///
  /// [Since 2.6.1] Bits 16-30 are relevant to GX and OpenType variation
  /// fonts only, specifying the named instance index for the current face
  /// index (starting with value~1; value~0 makes FreeType ignore named
  /// instances).  For non-variation fonts, bits 16-30 are ignored.
  /// Assuming that you want to access the third named instance in face~4,
  /// `face_index` should be set to 0x00030004.  If you want to access
  /// face~4 without variation handling, simply set `face_index` to
  /// value~4.
  ///
  /// `FT_Open_Face` and its siblings can be used to quickly check whether
  /// the font format of a given font resource is supported by FreeType.
  /// In general, if the `face_index` argument is negative, the function's
  /// return value is~0 if the font format is recognized, or non-zero
  /// otherwise.  The function allocates a more or less empty face handle
  /// in `*aface` (if `aface` isn't `NULL`); the only two useful fields in
  /// this special case are `face->num_faces` and `face->style_flags`.
  /// For any negative value of `face_index`, `face->num_faces` gives the
  /// number of faces within the font file.  For the negative value
  /// '-(N+1)' (with 'N' a non-negative 16-bit value), bits 16-30 in
  /// `face->style_flags` give the number of named instances in face 'N'
  /// if we have a variation font (or zero otherwise).  After examination,
  /// the returned @FT_Face structure should be deallocated with a call to
  /// @FT_Done_Face.
  ///
  /// @output:
  /// aface ::
  /// A handle to a new face object.  If `face_index` is greater than or
  /// equal to zero, it must be non-`NULL`.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// Unlike FreeType 1.x, this function automatically creates a glyph slot
  /// for the face object that can be accessed directly through
  /// `face->glyph`.
  ///
  /// Each new face object created with this function also owns a default
  /// @FT_Size object, accessible as `face->size`.
  ///
  /// One @FT_Library instance can have multiple face objects, this is,
  /// @FT_Open_Face and its siblings can be called multiple times using the
  /// same `library` argument.
  ///
  /// See the discussion of reference counters in the description of
  /// @FT_Reference_Face.
  ///
  /// If `FT_OPEN_STREAM` is set in `args->flags`, the stream in
  /// `args->stream` is automatically closed before this function returns
  /// any error (including `FT_Err_Invalid_Argument`).
  ///
  /// @example:
  /// To loop over all faces, use code similar to the following snippet
  /// (omitting the error handling).
  ///
  /// ```
  /// ...
  /// FT_Face  face;
  /// FT_Long  i, num_faces;
  ///
  ///
  /// error = FT_Open_Face( library, args, -1, &face );
  /// if ( error ) { ... }
  ///
  /// num_faces = face->num_faces;
  /// FT_Done_Face( face );
  ///
  /// for ( i = 0; i < num_faces; i++ )
  /// {
  /// ...
  /// error = FT_Open_Face( library, args, i, &face );
  /// ...
  /// FT_Done_Face( face );
  /// ...
  /// }
  /// ```
  ///
  /// To loop over all valid values for `face_index`, use something similar
  /// to the following snippet, again without error handling.  The code
  /// accesses all faces immediately (thus only a single call of
  /// `FT_Open_Face` within the do-loop), with and without named instances.
  ///
  /// ```
  /// ...
  /// FT_Face  face;
  ///
  /// FT_Long  num_faces     = 0;
  /// FT_Long  num_instances = 0;
  ///
  /// FT_Long  face_idx     = 0;
  /// FT_Long  instance_idx = 0;
  ///
  ///
  /// do
  /// {
  /// FT_Long  id = ( instance_idx << 16 ) + face_idx;
  ///
  ///
  /// error = FT_Open_Face( library, args, id, &face );
  /// if ( error ) { ... }
  ///
  /// num_faces     = face->num_faces;
  /// num_instances = face->style_flags >> 16;
  ///
  /// ...
  ///
  /// FT_Done_Face( face );
  ///
  /// if ( instance_idx < num_instances )
  /// instance_idx++;
  /// else
  /// {
  /// face_idx++;
  /// instance_idx = 0;
  /// }
  ///
  /// } while ( face_idx < num_faces )
  /// ```
  int FT_Open_Face(
    FT_Library library1,
    ffi.Pointer<FT_Open_Args> args,
    int face_index,
    ffi.Pointer<FT_Face> aface,
  ) {
    return _FT_Open_Face(
      library1,
      args,
      face_index,
      aface,
    );
  }

  late final _FT_Open_FacePtr = _lookup<
      ffi.NativeFunction<
          FT_Error Function(FT_Library, ffi.Pointer<FT_Open_Args>, FT_Long,
              ffi.Pointer<FT_Face>)>>('FT_Open_Face');
  late final _FT_Open_Face = _FT_Open_FacePtr.asFunction<
      int Function(
          FT_Library, ffi.Pointer<FT_Open_Args>, int, ffi.Pointer<FT_Face>)>();

  /// @function:
  /// FT_Attach_File
  ///
  /// @description:
  /// Call @FT_Attach_Stream to attach a file.
  ///
  /// @inout:
  /// face ::
  /// The target face object.
  ///
  /// @input:
  /// filepathname ::
  /// The pathname.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  int FT_Attach_File(
    FT_Face face,
    ffi.Pointer<ffi.Char> filepathname,
  ) {
    return _FT_Attach_File(
      face,
      filepathname,
    );
  }

  late final _FT_Attach_FilePtr = _lookup<
      ffi.NativeFunction<
          FT_Error Function(FT_Face, ffi.Pointer<ffi.Char>)>>('FT_Attach_File');
  late final _FT_Attach_File = _FT_Attach_FilePtr.asFunction<
      int Function(FT_Face, ffi.Pointer<ffi.Char>)>();

  /// @function:
  /// FT_Attach_Stream
  ///
  /// @description:
  /// 'Attach' data to a face object.  Normally, this is used to read
  /// additional information for the face object.  For example, you can
  /// attach an AFM file that comes with a Type~1 font to get the kerning
  /// values and other metrics.
  ///
  /// @inout:
  /// face ::
  /// The target face object.
  ///
  /// @input:
  /// parameters ::
  /// A pointer to @FT_Open_Args that must be filled by the caller.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// The meaning of the 'attach' (i.e., what really happens when the new
  /// file is read) is not fixed by FreeType itself.  It really depends on
  /// the font format (and thus the font driver).
  ///
  /// Client applications are expected to know what they are doing when
  /// invoking this function.  Most drivers simply do not implement file or
  /// stream attachments.
  int FT_Attach_Stream(
    FT_Face face,
    ffi.Pointer<FT_Open_Args> parameters,
  ) {
    return _FT_Attach_Stream(
      face,
      parameters,
    );
  }

  late final _FT_Attach_StreamPtr = _lookup<
      ffi.NativeFunction<
          FT_Error Function(
              FT_Face, ffi.Pointer<FT_Open_Args>)>>('FT_Attach_Stream');
  late final _FT_Attach_Stream = _FT_Attach_StreamPtr.asFunction<
      int Function(FT_Face, ffi.Pointer<FT_Open_Args>)>();

  /// @function:
  /// FT_Reference_Face
  ///
  /// @description:
  /// A counter gets initialized to~1 at the time an @FT_Face structure is
  /// created.  This function increments the counter.  @FT_Done_Face then
  /// only destroys a face if the counter is~1, otherwise it simply
  /// decrements the counter.
  ///
  /// This function helps in managing life-cycles of structures that
  /// reference @FT_Face objects.
  ///
  /// @input:
  /// face ::
  /// A handle to a target face object.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @since:
  /// 2.4.2
  int FT_Reference_Face(
    FT_Face face,
  ) {
    return _FT_Reference_Face(
      face,
    );
  }

  late final _FT_Reference_FacePtr =
      _lookup<ffi.NativeFunction<FT_Error Function(FT_Face)>>(
          'FT_Reference_Face');
  late final _FT_Reference_Face =
      _FT_Reference_FacePtr.asFunction<int Function(FT_Face)>();

  /// @function:
  /// FT_Done_Face
  ///
  /// @description:
  /// Discard a given face object, as well as all of its child slots and
  /// sizes.
  ///
  /// @input:
  /// face ::
  /// A handle to a target face object.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// See the discussion of reference counters in the description of
  /// @FT_Reference_Face.
  int FT_Done_Face(
    FT_Face face,
  ) {
    return _FT_Done_Face(
      face,
    );
  }

  late final _FT_Done_FacePtr =
      _lookup<ffi.NativeFunction<FT_Error Function(FT_Face)>>('FT_Done_Face');
  late final _FT_Done_Face =
      _FT_Done_FacePtr.asFunction<int Function(FT_Face)>();

  /// @function:
  /// FT_Select_Size
  ///
  /// @description:
  /// Select a bitmap strike.  To be more precise, this function sets the
  /// scaling factors of the active @FT_Size object in a face so that
  /// bitmaps from this particular strike are taken by @FT_Load_Glyph and
  /// friends.
  ///
  /// @inout:
  /// face ::
  /// A handle to a target face object.
  ///
  /// @input:
  /// strike_index ::
  /// The index of the bitmap strike in the `available_sizes` field of
  /// @FT_FaceRec structure.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// For bitmaps embedded in outline fonts it is common that only a subset
  /// of the available glyphs at a given ppem value is available.  FreeType
  /// silently uses outlines if there is no bitmap for a given glyph index.
  ///
  /// For GX and OpenType variation fonts, a bitmap strike makes sense only
  /// if the default instance is active (this is, no glyph variation takes
  /// place); otherwise, FreeType simply ignores bitmap strikes.  The same
  /// is true for all named instances that are different from the default
  /// instance.
  ///
  /// Don't use this function if you are using the FreeType cache API.
  int FT_Select_Size(
    FT_Face face,
    int strike_index,
  ) {
    return _FT_Select_Size(
      face,
      strike_index,
    );
  }

  late final _FT_Select_SizePtr =
      _lookup<ffi.NativeFunction<FT_Error Function(FT_Face, FT_Int)>>(
          'FT_Select_Size');
  late final _FT_Select_Size =
      _FT_Select_SizePtr.asFunction<int Function(FT_Face, int)>();

  /// @function:
  /// FT_Request_Size
  ///
  /// @description:
  /// Resize the scale of the active @FT_Size object in a face.
  ///
  /// @inout:
  /// face ::
  /// A handle to a target face object.
  ///
  /// @input:
  /// req ::
  /// A pointer to a @FT_Size_RequestRec.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// Although drivers may select the bitmap strike matching the request,
  /// you should not rely on this if you intend to select a particular
  /// bitmap strike.  Use @FT_Select_Size instead in that case.
  ///
  /// The relation between the requested size and the resulting glyph size
  /// is dependent entirely on how the size is defined in the source face.
  /// The font designer chooses the final size of each glyph relative to
  /// this size.  For more information refer to
  /// 'https://www.freetype.org/freetype2/docs/glyphs/glyphs-2.html'.
  ///
  /// Contrary to @FT_Set_Char_Size, this function doesn't have special code
  /// to normalize zero-valued widths, heights, or resolutions, which are
  /// treated as @FT_LOAD_NO_SCALE.
  ///
  /// Don't use this function if you are using the FreeType cache API.
  int FT_Request_Size(
    FT_Face face,
    FT_Size_Request req,
  ) {
    return _FT_Request_Size(
      face,
      req,
    );
  }

  late final _FT_Request_SizePtr =
      _lookup<ffi.NativeFunction<FT_Error Function(FT_Face, FT_Size_Request)>>(
          'FT_Request_Size');
  late final _FT_Request_Size =
      _FT_Request_SizePtr.asFunction<int Function(FT_Face, FT_Size_Request)>();

  /// @function:
  /// FT_Set_Char_Size
  ///
  /// @description:
  /// Call @FT_Request_Size to request the nominal size (in points).
  ///
  /// @inout:
  /// face ::
  /// A handle to a target face object.
  ///
  /// @input:
  /// char_width ::
  /// The nominal width, in 26.6 fractional points.
  ///
  /// char_height ::
  /// The nominal height, in 26.6 fractional points.
  ///
  /// horz_resolution ::
  /// The horizontal resolution in dpi.
  ///
  /// vert_resolution ::
  /// The vertical resolution in dpi.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// While this function allows fractional points as input values, the
  /// resulting ppem value for the given resolution is always rounded to the
  /// nearest integer.
  ///
  /// If either the character width or height is zero, it is set equal to
  /// the other value.
  ///
  /// If either the horizontal or vertical resolution is zero, it is set
  /// equal to the other value.
  ///
  /// A character width or height smaller than 1pt is set to 1pt; if both
  /// resolution values are zero, they are set to 72dpi.
  ///
  /// Don't use this function if you are using the FreeType cache API.
  int FT_Set_Char_Size(
    FT_Face face,
    int char_width,
    int char_height,
    int horz_resolution,
    int vert_resolution,
  ) {
    return _FT_Set_Char_Size(
      face,
      char_width,
      char_height,
      horz_resolution,
      vert_resolution,
    );
  }

  late final _FT_Set_Char_SizePtr = _lookup<
      ffi.NativeFunction<
          FT_Error Function(FT_Face, FT_F26Dot6, FT_F26Dot6, FT_UInt,
              FT_UInt)>>('FT_Set_Char_Size');
  late final _FT_Set_Char_Size = _FT_Set_Char_SizePtr.asFunction<
      int Function(FT_Face, int, int, int, int)>();

  /// @function:
  /// FT_Set_Pixel_Sizes
  ///
  /// @description:
  /// Call @FT_Request_Size to request the nominal size (in pixels).
  ///
  /// @inout:
  /// face ::
  /// A handle to the target face object.
  ///
  /// @input:
  /// pixel_width ::
  /// The nominal width, in pixels.
  ///
  /// pixel_height ::
  /// The nominal height, in pixels.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// You should not rely on the resulting glyphs matching or being
  /// constrained to this pixel size.  Refer to @FT_Request_Size to
  /// understand how requested sizes relate to actual sizes.
  ///
  /// Don't use this function if you are using the FreeType cache API.
  int FT_Set_Pixel_Sizes(
    FT_Face face,
    int pixel_width,
    int pixel_height,
  ) {
    return _FT_Set_Pixel_Sizes(
      face,
      pixel_width,
      pixel_height,
    );
  }

  late final _FT_Set_Pixel_SizesPtr =
      _lookup<ffi.NativeFunction<FT_Error Function(FT_Face, FT_UInt, FT_UInt)>>(
          'FT_Set_Pixel_Sizes');
  late final _FT_Set_Pixel_Sizes =
      _FT_Set_Pixel_SizesPtr.asFunction<int Function(FT_Face, int, int)>();

  /// @function:
  /// FT_Load_Glyph
  ///
  /// @description:
  /// Load a glyph into the glyph slot of a face object.
  ///
  /// @inout:
  /// face ::
  /// A handle to the target face object where the glyph is loaded.
  ///
  /// @input:
  /// glyph_index ::
  /// The index of the glyph in the font file.  For CID-keyed fonts
  /// (either in PS or in CFF format) this argument specifies the CID
  /// value.
  ///
  /// load_flags ::
  /// A flag indicating what to load for this glyph.  The @FT_LOAD_XXX
  /// flags can be used to control the glyph loading process (e.g.,
  /// whether the outline should be scaled, whether to load bitmaps or
  /// not, whether to hint the outline, etc).
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// For proper scaling and hinting, the active @FT_Size object owned by
  /// the face has to be meaningfully initialized by calling
  /// @FT_Set_Char_Size before this function, for example.  The loaded
  /// glyph may be transformed.  See @FT_Set_Transform for the details.
  ///
  /// For subsetted CID-keyed fonts, `FT_Err_Invalid_Argument` is returned
  /// for invalid CID values (this is, for CID values that don't have a
  /// corresponding glyph in the font).  See the discussion of the
  /// @FT_FACE_FLAG_CID_KEYED flag for more details.
  ///
  /// If you receive `FT_Err_Glyph_Too_Big`, try getting the glyph outline
  /// at EM size, then scale it manually and fill it as a graphics
  /// operation.
  int FT_Load_Glyph(
    FT_Face face,
    int glyph_index,
    int load_flags,
  ) {
    return _FT_Load_Glyph(
      face,
      glyph_index,
      load_flags,
    );
  }

  late final _FT_Load_GlyphPtr = _lookup<
          ffi.NativeFunction<FT_Error Function(FT_Face, FT_UInt, FT_Int32)>>(
      'FT_Load_Glyph');
  late final _FT_Load_Glyph =
      _FT_Load_GlyphPtr.asFunction<int Function(FT_Face, int, int)>();

  /// @function:
  /// FT_Load_Char
  ///
  /// @description:
  /// Load a glyph into the glyph slot of a face object, accessed by its
  /// character code.
  ///
  /// @inout:
  /// face ::
  /// A handle to a target face object where the glyph is loaded.
  ///
  /// @input:
  /// char_code ::
  /// The glyph's character code, according to the current charmap used in
  /// the face.
  ///
  /// load_flags ::
  /// A flag indicating what to load for this glyph.  The @FT_LOAD_XXX
  /// constants can be used to control the glyph loading process (e.g.,
  /// whether the outline should be scaled, whether to load bitmaps or
  /// not, whether to hint the outline, etc).
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// This function simply calls @FT_Get_Char_Index and @FT_Load_Glyph.
  ///
  /// Many fonts contain glyphs that can't be loaded by this function since
  /// its glyph indices are not listed in any of the font's charmaps.
  ///
  /// If no active cmap is set up (i.e., `face->charmap` is zero), the call
  /// to @FT_Get_Char_Index is omitted, and the function behaves identically
  /// to @FT_Load_Glyph.
  int FT_Load_Char(
    FT_Face face,
    int char_code,
    int load_flags,
  ) {
    return _FT_Load_Char(
      face,
      char_code,
      load_flags,
    );
  }

  late final _FT_Load_CharPtr = _lookup<
          ffi.NativeFunction<FT_Error Function(FT_Face, FT_ULong, FT_Int32)>>(
      'FT_Load_Char');
  late final _FT_Load_Char =
      _FT_Load_CharPtr.asFunction<int Function(FT_Face, int, int)>();

  /// @function:
  /// FT_Set_Transform
  ///
  /// @description:
  /// Set the transformation that is applied to glyph images when they are
  /// loaded into a glyph slot through @FT_Load_Glyph.
  ///
  /// @inout:
  /// face ::
  /// A handle to the source face object.
  ///
  /// @input:
  /// matrix ::
  /// A pointer to the transformation's 2x2 matrix.  Use `NULL` for the
  /// identity matrix.
  /// delta ::
  /// A pointer to the translation vector.  Use `NULL` for the null
  /// vector.
  ///
  /// @note:
  /// This function is provided as a convenience, but keep in mind that
  /// @FT_Matrix coefficients are only 16.16 fixed-point values, which can
  /// limit the accuracy of the results.  Using floating-point computations
  /// to perform the transform directly in client code instead will always
  /// yield better numbers.
  ///
  /// The transformation is only applied to scalable image formats after the
  /// glyph has been loaded.  It means that hinting is unaltered by the
  /// transformation and is performed on the character size given in the
  /// last call to @FT_Set_Char_Size or @FT_Set_Pixel_Sizes.
  ///
  /// Note that this also transforms the `face.glyph.advance` field, but
  /// **not** the values in `face.glyph.metrics`.
  void FT_Set_Transform(
    FT_Face face,
    ffi.Pointer<FT_Matrix> matrix,
    ffi.Pointer<FT_Vector> delta,
  ) {
    return _FT_Set_Transform(
      face,
      matrix,
      delta,
    );
  }

  late final _FT_Set_TransformPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(FT_Face, ffi.Pointer<FT_Matrix>,
              ffi.Pointer<FT_Vector>)>>('FT_Set_Transform');
  late final _FT_Set_Transform = _FT_Set_TransformPtr.asFunction<
      void Function(FT_Face, ffi.Pointer<FT_Matrix>, ffi.Pointer<FT_Vector>)>();

  /// @function:
  /// FT_Get_Transform
  ///
  /// @description:
  /// Return the transformation that is applied to glyph images when they
  /// are loaded into a glyph slot through @FT_Load_Glyph.  See
  /// @FT_Set_Transform for more details.
  ///
  /// @input:
  /// face ::
  /// A handle to the source face object.
  ///
  /// @output:
  /// matrix ::
  /// A pointer to a transformation's 2x2 matrix.  Set this to NULL if you
  /// are not interested in the value.
  ///
  /// delta ::
  /// A pointer to a translation vector.  Set this to NULL if you are not
  /// interested in the value.
  ///
  /// @since:
  /// 2.11
  void FT_Get_Transform(
    FT_Face face,
    ffi.Pointer<FT_Matrix> matrix,
    ffi.Pointer<FT_Vector> delta,
  ) {
    return _FT_Get_Transform(
      face,
      matrix,
      delta,
    );
  }

  late final _FT_Get_TransformPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(FT_Face, ffi.Pointer<FT_Matrix>,
              ffi.Pointer<FT_Vector>)>>('FT_Get_Transform');
  late final _FT_Get_Transform = _FT_Get_TransformPtr.asFunction<
      void Function(FT_Face, ffi.Pointer<FT_Matrix>, ffi.Pointer<FT_Vector>)>();

  /// @function:
  /// FT_Render_Glyph
  ///
  /// @description:
  /// Convert a given glyph image to a bitmap.  It does so by inspecting the
  /// glyph image format, finding the relevant renderer, and invoking it.
  ///
  /// @inout:
  /// slot ::
  /// A handle to the glyph slot containing the image to convert.
  ///
  /// @input:
  /// render_mode ::
  /// The render mode used to render the glyph image into a bitmap.  See
  /// @FT_Render_Mode for a list of possible values.
  ///
  /// If @FT_RENDER_MODE_NORMAL is used, a previous call of @FT_Load_Glyph
  /// with flag @FT_LOAD_COLOR makes `FT_Render_Glyph` provide a default
  /// blending of colored glyph layers associated with the current glyph
  /// slot (provided the font contains such layers) instead of rendering
  /// the glyph slot's outline.  This is an experimental feature; see
  /// @FT_LOAD_COLOR for more information.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// When FreeType outputs a bitmap of a glyph, it really outputs an alpha
  /// coverage map.  If a pixel is completely covered by a filled-in
  /// outline, the bitmap contains 0xFF at that pixel, meaning that
  /// 0xFF/0xFF fraction of that pixel is covered, meaning the pixel is 100%
  /// black (or 0% bright).  If a pixel is only 50% covered (value 0x80),
  /// the pixel is made 50% black (50% bright or a middle shade of grey).
  /// 0% covered means 0% black (100% bright or white).
  ///
  /// On high-DPI screens like on smartphones and tablets, the pixels are so
  /// small that their chance of being completely covered and therefore
  /// completely black are fairly good.  On the low-DPI screens, however,
  /// the situation is different.  The pixels are too large for most of the
  /// details of a glyph and shades of gray are the norm rather than the
  /// exception.
  ///
  /// This is relevant because all our screens have a second problem: they
  /// are not linear.  1~+~1 is not~2.  Twice the value does not result in
  /// twice the brightness.  When a pixel is only 50% covered, the coverage
  /// map says 50% black, and this translates to a pixel value of 128 when
  /// you use 8~bits per channel (0-255).  However, this does not translate
  /// to 50% brightness for that pixel on our sRGB and gamma~2.2 screens.
  /// Due to their non-linearity, they dwell longer in the darks and only a
  /// pixel value of about 186 results in 50% brightness -- 128 ends up too
  /// dark on both bright and dark backgrounds.  The net result is that dark
  /// text looks burnt-out, pixely and blotchy on bright background, bright
  /// text too frail on dark backgrounds, and colored text on colored
  /// background (for example, red on green) seems to have dark halos or
  /// 'dirt' around it.  The situation is especially ugly for diagonal stems
  /// like in 'w' glyph shapes where the quality of FreeType's anti-aliasing
  /// depends on the correct display of grays.  On high-DPI screens where
  /// smaller, fully black pixels reign supreme, this doesn't matter, but on
  /// our low-DPI screens with all the gray shades, it does.  0% and 100%
  /// brightness are the same things in linear and non-linear space, just
  /// all the shades in-between aren't.
  ///
  /// The blending function for placing text over a background is
  ///
  /// ```
  /// dst = alpha * src + (1 - alpha) * dst    ,
  /// ```
  ///
  /// which is known as the OVER operator.
  ///
  /// To correctly composite an anti-aliased pixel of a glyph onto a
  /// surface,
  ///
  /// 1. take the foreground and background colors (e.g., in sRGB space)
  /// and apply gamma to get them in a linear space,
  ///
  /// 2. use OVER to blend the two linear colors using the glyph pixel
  /// as the alpha value (remember, the glyph bitmap is an alpha coverage
  /// bitmap), and
  ///
  /// 3. apply inverse gamma to the blended pixel and write it back to
  /// the image.
  ///
  /// Internal testing at Adobe found that a target inverse gamma of~1.8 for
  /// step~3 gives good results across a wide range of displays with an sRGB
  /// gamma curve or a similar one.
  ///
  /// This process can cost performance.  There is an approximation that
  /// does not need to know about the background color; see
  /// https://bel.fi/alankila/lcd/ and
  /// https://bel.fi/alankila/lcd/alpcor.html for details.
  ///
  /// **ATTENTION**: Linear blending is even more important when dealing
  /// with subpixel-rendered glyphs to prevent color-fringing!  A
  /// subpixel-rendered glyph must first be filtered with a filter that
  /// gives equal weight to the three color primaries and does not exceed a
  /// sum of 0x100, see section @lcd_rendering.  Then the only difference to
  /// gray linear blending is that subpixel-rendered linear blending is done
  /// 3~times per pixel: red foreground subpixel to red background subpixel
  /// and so on for green and blue.
  int FT_Render_Glyph(
    FT_GlyphSlot slot,
    int render_mode,
  ) {
    return _FT_Render_Glyph(
      slot,
      render_mode,
    );
  }

  late final _FT_Render_GlyphPtr =
      _lookup<ffi.NativeFunction<FT_Error Function(FT_GlyphSlot, ffi.Int32)>>(
          'FT_Render_Glyph');
  late final _FT_Render_Glyph =
      _FT_Render_GlyphPtr.asFunction<int Function(FT_GlyphSlot, int)>();

  /// @function:
  /// FT_Get_Kerning
  ///
  /// @description:
  /// Return the kerning vector between two glyphs of the same face.
  ///
  /// @input:
  /// face ::
  /// A handle to a source face object.
  ///
  /// left_glyph ::
  /// The index of the left glyph in the kern pair.
  ///
  /// right_glyph ::
  /// The index of the right glyph in the kern pair.
  ///
  /// kern_mode ::
  /// See @FT_Kerning_Mode for more information.  Determines the scale and
  /// dimension of the returned kerning vector.
  ///
  /// @output:
  /// akerning ::
  /// The kerning vector.  This is either in font units, fractional pixels
  /// (26.6 format), or pixels for scalable formats, and in pixels for
  /// fixed-sizes formats.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// Only horizontal layouts (left-to-right & right-to-left) are supported
  /// by this method.  Other layouts, or more sophisticated kernings, are
  /// out of the scope of this API function -- they can be implemented
  /// through format-specific interfaces.
  ///
  /// Kerning for OpenType fonts implemented in a 'GPOS' table is not
  /// supported; use @FT_HAS_KERNING to find out whether a font has data
  /// that can be extracted with `FT_Get_Kerning`.
  int FT_Get_Kerning(
    FT_Face face,
    int left_glyph,
    int right_glyph,
    int kern_mode,
    ffi.Pointer<FT_Vector> akerning,
  ) {
    return _FT_Get_Kerning(
      face,
      left_glyph,
      right_glyph,
      kern_mode,
      akerning,
    );
  }

  late final _FT_Get_KerningPtr = _lookup<
      ffi.NativeFunction<
          FT_Error Function(FT_Face, FT_UInt, FT_UInt, FT_UInt,
              ffi.Pointer<FT_Vector>)>>('FT_Get_Kerning');
  late final _FT_Get_Kerning = _FT_Get_KerningPtr.asFunction<
      int Function(FT_Face, int, int, int, ffi.Pointer<FT_Vector>)>();

  /// @function:
  /// FT_Get_Track_Kerning
  ///
  /// @description:
  /// Return the track kerning for a given face object at a given size.
  ///
  /// @input:
  /// face ::
  /// A handle to a source face object.
  ///
  /// point_size ::
  /// The point size in 16.16 fractional points.
  ///
  /// degree ::
  /// The degree of tightness.  Increasingly negative values represent
  /// tighter track kerning, while increasingly positive values represent
  /// looser track kerning.  Value zero means no track kerning.
  ///
  /// @output:
  /// akerning ::
  /// The kerning in 16.16 fractional points, to be uniformly applied
  /// between all glyphs.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// Currently, only the Type~1 font driver supports track kerning, using
  /// data from AFM files (if attached with @FT_Attach_File or
  /// @FT_Attach_Stream).
  ///
  /// Only very few AFM files come with track kerning data; please refer to
  /// Adobe's AFM specification for more details.
  int FT_Get_Track_Kerning(
    FT_Face face,
    int point_size,
    int degree,
    ffi.Pointer<FT_Fixed> akerning,
  ) {
    return _FT_Get_Track_Kerning(
      face,
      point_size,
      degree,
      akerning,
    );
  }

  late final _FT_Get_Track_KerningPtr = _lookup<
      ffi.NativeFunction<
          FT_Error Function(FT_Face, FT_Fixed, FT_Int,
              ffi.Pointer<FT_Fixed>)>>('FT_Get_Track_Kerning');
  late final _FT_Get_Track_Kerning = _FT_Get_Track_KerningPtr.asFunction<
      int Function(FT_Face, int, int, ffi.Pointer<FT_Fixed>)>();

  /// @function:
  /// FT_Select_Charmap
  ///
  /// @description:
  /// Select a given charmap by its encoding tag (as listed in
  /// `freetype.h`).
  ///
  /// @inout:
  /// face ::
  /// A handle to the source face object.
  ///
  /// @input:
  /// encoding ::
  /// A handle to the selected encoding.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// This function returns an error if no charmap in the face corresponds
  /// to the encoding queried here.
  ///
  /// Because many fonts contain more than a single cmap for Unicode
  /// encoding, this function has some special code to select the one that
  /// covers Unicode best ('best' in the sense that a UCS-4 cmap is
  /// preferred to a UCS-2 cmap).  It is thus preferable to @FT_Set_Charmap
  /// in this case.
  int FT_Select_Charmap(
    FT_Face face,
    int encoding,
  ) {
    return _FT_Select_Charmap(
      face,
      encoding,
    );
  }

  late final _FT_Select_CharmapPtr =
      _lookup<ffi.NativeFunction<FT_Error Function(FT_Face, ffi.Int32)>>(
          'FT_Select_Charmap');
  late final _FT_Select_Charmap =
      _FT_Select_CharmapPtr.asFunction<int Function(FT_Face, int)>();

  /// @function:
  /// FT_Set_Charmap
  ///
  /// @description:
  /// Select a given charmap for character code to glyph index mapping.
  ///
  /// @inout:
  /// face ::
  /// A handle to the source face object.
  ///
  /// @input:
  /// charmap ::
  /// A handle to the selected charmap.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// This function returns an error if the charmap is not part of the face
  /// (i.e., if it is not listed in the `face->charmaps` table).
  ///
  /// It also fails if an OpenType type~14 charmap is selected (which
  /// doesn't map character codes to glyph indices at all).
  int FT_Set_Charmap(
    FT_Face face,
    FT_CharMap charmap,
  ) {
    return _FT_Set_Charmap(
      face,
      charmap,
    );
  }

  late final _FT_Set_CharmapPtr =
      _lookup<ffi.NativeFunction<FT_Error Function(FT_Face, FT_CharMap)>>(
          'FT_Set_Charmap');
  late final _FT_Set_Charmap =
      _FT_Set_CharmapPtr.asFunction<int Function(FT_Face, FT_CharMap)>();

  /// @function:
  /// FT_Get_Charmap_Index
  ///
  /// @description:
  /// Retrieve index of a given charmap.
  ///
  /// @input:
  /// charmap ::
  /// A handle to a charmap.
  ///
  /// @return:
  /// The index into the array of character maps within the face to which
  /// `charmap` belongs.  If an error occurs, -1 is returned.
  int FT_Get_Charmap_Index(
    FT_CharMap charmap,
  ) {
    return _FT_Get_Charmap_Index(
      charmap,
    );
  }

  late final _FT_Get_Charmap_IndexPtr =
      _lookup<ffi.NativeFunction<FT_Int Function(FT_CharMap)>>(
          'FT_Get_Charmap_Index');
  late final _FT_Get_Charmap_Index =
      _FT_Get_Charmap_IndexPtr.asFunction<int Function(FT_CharMap)>();

  /// @function:
  /// FT_Get_Char_Index
  ///
  /// @description:
  /// Return the glyph index of a given character code.  This function uses
  /// the currently selected charmap to do the mapping.
  ///
  /// @input:
  /// face ::
  /// A handle to the source face object.
  ///
  /// charcode ::
  /// The character code.
  ///
  /// @return:
  /// The glyph index.  0~means 'undefined character code'.
  ///
  /// @note:
  /// If you use FreeType to manipulate the contents of font files directly,
  /// be aware that the glyph index returned by this function doesn't always
  /// correspond to the internal indices used within the file.  This is done
  /// to ensure that value~0 always corresponds to the 'missing glyph'.  If
  /// the first glyph is not named '.notdef', then for Type~1 and Type~42
  /// fonts, '.notdef' will be moved into the glyph ID~0 position, and
  /// whatever was there will be moved to the position '.notdef' had.  For
  /// Type~1 fonts, if there is no '.notdef' glyph at all, then one will be
  /// created at index~0 and whatever was there will be moved to the last
  /// index -- Type~42 fonts are considered invalid under this condition.
  int FT_Get_Char_Index(
    FT_Face face,
    int charcode,
  ) {
    return _FT_Get_Char_Index(
      face,
      charcode,
    );
  }

  late final _FT_Get_Char_IndexPtr =
      _lookup<ffi.NativeFunction<FT_UInt Function(FT_Face, FT_ULong)>>(
          'FT_Get_Char_Index');
  late final _FT_Get_Char_Index =
      _FT_Get_Char_IndexPtr.asFunction<int Function(FT_Face, int)>();

  /// @function:
  /// FT_Get_First_Char
  ///
  /// @description:
  /// Return the first character code in the current charmap of a given
  /// face, together with its corresponding glyph index.
  ///
  /// @input:
  /// face ::
  /// A handle to the source face object.
  ///
  /// @output:
  /// agindex ::
  /// Glyph index of first character code.  0~if charmap is empty.
  ///
  /// @return:
  /// The charmap's first character code.
  ///
  /// @note:
  /// You should use this function together with @FT_Get_Next_Char to parse
  /// all character codes available in a given charmap.  The code should
  /// look like this:
  ///
  /// ```
  /// FT_ULong  charcode;
  /// FT_UInt   gindex;
  ///
  ///
  /// charcode = FT_Get_First_Char( face, &gindex );
  /// while ( gindex != 0 )
  /// {
  /// ... do something with (charcode,gindex) pair ...
  ///
  /// charcode = FT_Get_Next_Char( face, charcode, &gindex );
  /// }
  /// ```
  ///
  /// Be aware that character codes can have values up to 0xFFFFFFFF; this
  /// might happen for non-Unicode or malformed cmaps.  However, even with
  /// regular Unicode encoding, so-called 'last resort fonts' (using SFNT
  /// cmap format 13, see function @FT_Get_CMap_Format) normally have
  /// entries for all Unicode characters up to 0x1FFFFF, which can cause *a
  /// lot* of iterations.
  ///
  /// Note that `*agindex` is set to~0 if the charmap is empty.  The result
  /// itself can be~0 in two cases: if the charmap is empty or if the
  /// value~0 is the first valid character code.
  int FT_Get_First_Char(
    FT_Face face,
    ffi.Pointer<FT_UInt> agindex,
  ) {
    return _FT_Get_First_Char(
      face,
      agindex,
    );
  }

  late final _FT_Get_First_CharPtr = _lookup<
          ffi.NativeFunction<FT_ULong Function(FT_Face, ffi.Pointer<FT_UInt>)>>(
      'FT_Get_First_Char');
  late final _FT_Get_First_Char = _FT_Get_First_CharPtr.asFunction<
      int Function(FT_Face, ffi.Pointer<FT_UInt>)>();

  /// @function:
  /// FT_Get_Next_Char
  ///
  /// @description:
  /// Return the next character code in the current charmap of a given face
  /// following the value `char_code`, as well as the corresponding glyph
  /// index.
  ///
  /// @input:
  /// face ::
  /// A handle to the source face object.
  ///
  /// char_code ::
  /// The starting character code.
  ///
  /// @output:
  /// agindex ::
  /// Glyph index of next character code.  0~if charmap is empty.
  ///
  /// @return:
  /// The charmap's next character code.
  ///
  /// @note:
  /// You should use this function with @FT_Get_First_Char to walk over all
  /// character codes available in a given charmap.  See the note for that
  /// function for a simple code example.
  ///
  /// Note that `*agindex` is set to~0 when there are no more codes in the
  /// charmap.
  int FT_Get_Next_Char(
    FT_Face face,
    int char_code,
    ffi.Pointer<FT_UInt> agindex,
  ) {
    return _FT_Get_Next_Char(
      face,
      char_code,
      agindex,
    );
  }

  late final _FT_Get_Next_CharPtr = _lookup<
      ffi.NativeFunction<
          FT_ULong Function(
              FT_Face, FT_ULong, ffi.Pointer<FT_UInt>)>>('FT_Get_Next_Char');
  late final _FT_Get_Next_Char = _FT_Get_Next_CharPtr.asFunction<
      int Function(FT_Face, int, ffi.Pointer<FT_UInt>)>();

  /// @function:
  /// FT_Face_Properties
  ///
  /// @description:
  /// Set or override certain (library or module-wide) properties on a
  /// face-by-face basis.  Useful for finer-grained control and avoiding
  /// locks on shared structures (threads can modify their own faces as they
  /// see fit).
  ///
  /// Contrary to @FT_Property_Set, this function uses @FT_Parameter so that
  /// you can pass multiple properties to the target face in one call.  Note
  /// that only a subset of the available properties can be controlled.
  ///
  /// * @FT_PARAM_TAG_STEM_DARKENING (stem darkening, corresponding to the
  /// property `no-stem-darkening` provided by the 'autofit', 'cff',
  /// 'type1', and 't1cid' modules; see @no-stem-darkening).
  ///
  /// * @FT_PARAM_TAG_LCD_FILTER_WEIGHTS (LCD filter weights, corresponding
  /// to function @FT_Library_SetLcdFilterWeights).
  ///
  /// * @FT_PARAM_TAG_RANDOM_SEED (seed value for the CFF, Type~1, and CID
  /// 'random' operator, corresponding to the `random-seed` property
  /// provided by the 'cff', 'type1', and 't1cid' modules; see
  /// @random-seed).
  ///
  /// Pass `NULL` as `data` in @FT_Parameter for a given tag to reset the
  /// option and use the library or module default again.
  ///
  /// @input:
  /// face ::
  /// A handle to the source face object.
  ///
  /// num_properties ::
  /// The number of properties that follow.
  ///
  /// properties ::
  /// A handle to an @FT_Parameter array with `num_properties` elements.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @example:
  /// Here is an example that sets three properties.  You must define
  /// `FT_CONFIG_OPTION_SUBPIXEL_RENDERING` to make the LCD filter examples
  /// work.
  ///
  /// ```
  /// FT_Parameter         property1;
  /// FT_Bool              darken_stems = 1;
  ///
  /// FT_Parameter         property2;
  /// FT_LcdFiveTapFilter  custom_weight =
  /// { 0x11, 0x44, 0x56, 0x44, 0x11 };
  ///
  /// FT_Parameter         property3;
  /// FT_Int32             random_seed = 314159265;
  ///
  /// FT_Parameter         properties[3] = { property1,
  /// property2,
  /// property3 };
  ///
  ///
  /// property1.tag  = FT_PARAM_TAG_STEM_DARKENING;
  /// property1.data = &darken_stems;
  ///
  /// property2.tag  = FT_PARAM_TAG_LCD_FILTER_WEIGHTS;
  /// property2.data = custom_weight;
  ///
  /// property3.tag  = FT_PARAM_TAG_RANDOM_SEED;
  /// property3.data = &random_seed;
  ///
  /// FT_Face_Properties( face, 3, properties );
  /// ```
  ///
  /// The next example resets a single property to its default value.
  ///
  /// ```
  /// FT_Parameter  property;
  ///
  ///
  /// property.tag  = FT_PARAM_TAG_LCD_FILTER_WEIGHTS;
  /// property.data = NULL;
  ///
  /// FT_Face_Properties( face, 1, &property );
  /// ```
  ///
  /// @since:
  /// 2.8
  int FT_Face_Properties(
    FT_Face face,
    int num_properties,
    ffi.Pointer<FT_Parameter> properties,
  ) {
    return _FT_Face_Properties(
      face,
      num_properties,
      properties,
    );
  }

  late final _FT_Face_PropertiesPtr = _lookup<
      ffi.NativeFunction<
          FT_Error Function(FT_Face, FT_UInt,
              ffi.Pointer<FT_Parameter>)>>('FT_Face_Properties');
  late final _FT_Face_Properties = _FT_Face_PropertiesPtr.asFunction<
      int Function(FT_Face, int, ffi.Pointer<FT_Parameter>)>();

  /// @function:
  /// FT_Get_Name_Index
  ///
  /// @description:
  /// Return the glyph index of a given glyph name.  This only works
  /// for those faces where @FT_HAS_GLYPH_NAMES returns true.
  ///
  /// @input:
  /// face ::
  /// A handle to the source face object.
  ///
  /// glyph_name ::
  /// The glyph name.
  ///
  /// @return:
  /// The glyph index.  0~means 'undefined character code'.
  ///
  /// @note:
  /// Acceptable glyph names might come from the [Adobe Glyph
  /// List](https://github.com/adobe-type-tools/agl-aglfn).  See
  /// @FT_Get_Glyph_Name for the inverse functionality.
  ///
  /// This function has limited capabilities if the config macro
  /// `FT_CONFIG_OPTION_POSTSCRIPT_NAMES` is not defined in `ftoption.h`:
  /// It then works only for fonts that actually embed glyph names (which
  /// many recent OpenType fonts do not).
  int FT_Get_Name_Index(
    FT_Face face,
    ffi.Pointer<FT_String> glyph_name,
  ) {
    return _FT_Get_Name_Index(
      face,
      glyph_name,
    );
  }

  late final _FT_Get_Name_IndexPtr = _lookup<
      ffi.NativeFunction<
          FT_UInt Function(
              FT_Face, ffi.Pointer<FT_String>)>>('FT_Get_Name_Index');
  late final _FT_Get_Name_Index = _FT_Get_Name_IndexPtr.asFunction<
      int Function(FT_Face, ffi.Pointer<FT_String>)>();

  /// @function:
  /// FT_Get_Glyph_Name
  ///
  /// @description:
  /// Retrieve the ASCII name of a given glyph in a face.  This only works
  /// for those faces where @FT_HAS_GLYPH_NAMES returns true.
  ///
  /// @input:
  /// face ::
  /// A handle to a source face object.
  ///
  /// glyph_index ::
  /// The glyph index.
  ///
  /// buffer_max ::
  /// The maximum number of bytes available in the buffer.
  ///
  /// @output:
  /// buffer ::
  /// A pointer to a target buffer where the name is copied to.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// An error is returned if the face doesn't provide glyph names or if the
  /// glyph index is invalid.  In all cases of failure, the first byte of
  /// `buffer` is set to~0 to indicate an empty name.
  ///
  /// The glyph name is truncated to fit within the buffer if it is too
  /// long.  The returned string is always zero-terminated.
  ///
  /// Be aware that FreeType reorders glyph indices internally so that glyph
  /// index~0 always corresponds to the 'missing glyph' (called '.notdef').
  ///
  /// This function has limited capabilities if the config macro
  /// `FT_CONFIG_OPTION_POSTSCRIPT_NAMES` is not defined in `ftoption.h`:
  /// It then works only for fonts that actually embed glyph names (which
  /// many recent OpenType fonts do not).
  int FT_Get_Glyph_Name(
    FT_Face face,
    int glyph_index,
    FT_Pointer buffer,
    int buffer_max,
  ) {
    return _FT_Get_Glyph_Name(
      face,
      glyph_index,
      buffer,
      buffer_max,
    );
  }

  late final _FT_Get_Glyph_NamePtr = _lookup<
      ffi.NativeFunction<
          FT_Error Function(
              FT_Face, FT_UInt, FT_Pointer, FT_UInt)>>('FT_Get_Glyph_Name');
  late final _FT_Get_Glyph_Name = _FT_Get_Glyph_NamePtr.asFunction<
      int Function(FT_Face, int, FT_Pointer, int)>();

  /// @function:
  /// FT_Get_Postscript_Name
  ///
  /// @description:
  /// Retrieve the ASCII PostScript name of a given face, if available.
  /// This only works with PostScript, TrueType, and OpenType fonts.
  ///
  /// @input:
  /// face ::
  /// A handle to the source face object.
  ///
  /// @return:
  /// A pointer to the face's PostScript name.  `NULL` if unavailable.
  ///
  /// @note:
  /// The returned pointer is owned by the face and is destroyed with it.
  ///
  /// For variation fonts, this string changes if you select a different
  /// instance, and you have to call `FT_Get_PostScript_Name` again to
  /// retrieve it.  FreeType follows Adobe TechNote #5902, 'Generating
  /// PostScript Names for Fonts Using OpenType Font Variations'.
  ///
  /// https://download.macromedia.com/pub/developer/opentype/tech-notes/5902.AdobePSNameGeneration.html
  ///
  /// [Since 2.9] Special PostScript names for named instances are only
  /// returned if the named instance is set with @FT_Set_Named_Instance (and
  /// the font has corresponding entries in its 'fvar' table).  If
  /// @FT_IS_VARIATION returns true, the algorithmically derived PostScript
  /// name is provided, not looking up special entries for named instances.
  ffi.Pointer<ffi.Char> FT_Get_Postscript_Name(
    FT_Face face,
  ) {
    return _FT_Get_Postscript_Name(
      face,
    );
  }

  late final _FT_Get_Postscript_NamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(FT_Face)>>(
          'FT_Get_Postscript_Name');
  late final _FT_Get_Postscript_Name = _FT_Get_Postscript_NamePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(FT_Face)>();

  /// @function:
  /// FT_Get_SubGlyph_Info
  ///
  /// @description:
  /// Retrieve a description of a given subglyph.  Only use it if
  /// `glyph->format` is @FT_GLYPH_FORMAT_COMPOSITE; an error is returned
  /// otherwise.
  ///
  /// @input:
  /// glyph ::
  /// The source glyph slot.
  ///
  /// sub_index ::
  /// The index of the subglyph.  Must be less than
  /// `glyph->num_subglyphs`.
  ///
  /// @output:
  /// p_index ::
  /// The glyph index of the subglyph.
  ///
  /// p_flags ::
  /// The subglyph flags, see @FT_SUBGLYPH_FLAG_XXX.
  ///
  /// p_arg1 ::
  /// The subglyph's first argument (if any).
  ///
  /// p_arg2 ::
  /// The subglyph's second argument (if any).
  ///
  /// p_transform ::
  /// The subglyph transformation (if any).
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// The values of `*p_arg1`, `*p_arg2`, and `*p_transform` must be
  /// interpreted depending on the flags returned in `*p_flags`.  See the
  /// OpenType specification for details.
  ///
  /// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description
  int FT_Get_SubGlyph_Info(
    FT_GlyphSlot glyph,
    int sub_index,
    ffi.Pointer<FT_Int> p_index,
    ffi.Pointer<FT_UInt> p_flags,
    ffi.Pointer<FT_Int> p_arg1,
    ffi.Pointer<FT_Int> p_arg2,
    ffi.Pointer<FT_Matrix> p_transform,
  ) {
    return _FT_Get_SubGlyph_Info(
      glyph,
      sub_index,
      p_index,
      p_flags,
      p_arg1,
      p_arg2,
      p_transform,
    );
  }

  late final _FT_Get_SubGlyph_InfoPtr = _lookup<
      ffi.NativeFunction<
          FT_Error Function(
              FT_GlyphSlot,
              FT_UInt,
              ffi.Pointer<FT_Int>,
              ffi.Pointer<FT_UInt>,
              ffi.Pointer<FT_Int>,
              ffi.Pointer<FT_Int>,
              ffi.Pointer<FT_Matrix>)>>('FT_Get_SubGlyph_Info');
  late final _FT_Get_SubGlyph_Info = _FT_Get_SubGlyph_InfoPtr.asFunction<
      int Function(FT_GlyphSlot, int, ffi.Pointer<FT_Int>, ffi.Pointer<FT_UInt>,
          ffi.Pointer<FT_Int>, ffi.Pointer<FT_Int>, ffi.Pointer<FT_Matrix>)>();

  /// @function:
  /// FT_Get_FSType_Flags
  ///
  /// @description:
  /// Return the `fsType` flags for a font.
  ///
  /// @input:
  /// face ::
  /// A handle to the source face object.
  ///
  /// @return:
  /// The `fsType` flags, see @FT_FSTYPE_XXX.
  ///
  /// @note:
  /// Use this function rather than directly reading the `fs_type` field in
  /// the @PS_FontInfoRec structure, which is only guaranteed to return the
  /// correct results for Type~1 fonts.
  ///
  /// @since:
  /// 2.3.8
  int FT_Get_FSType_Flags(
    FT_Face face,
  ) {
    return _FT_Get_FSType_Flags(
      face,
    );
  }

  late final _FT_Get_FSType_FlagsPtr =
      _lookup<ffi.NativeFunction<FT_UShort Function(FT_Face)>>(
          'FT_Get_FSType_Flags');
  late final _FT_Get_FSType_Flags =
      _FT_Get_FSType_FlagsPtr.asFunction<int Function(FT_Face)>();

  /// @function:
  /// FT_Face_GetCharVariantIndex
  ///
  /// @description:
  /// Return the glyph index of a given character code as modified by the
  /// variation selector.
  ///
  /// @input:
  /// face ::
  /// A handle to the source face object.
  ///
  /// charcode ::
  /// The character code point in Unicode.
  ///
  /// variantSelector ::
  /// The Unicode code point of the variation selector.
  ///
  /// @return:
  /// The glyph index.  0~means either 'undefined character code', or
  /// 'undefined selector code', or 'no variation selector cmap subtable',
  /// or 'current CharMap is not Unicode'.
  ///
  /// @note:
  /// If you use FreeType to manipulate the contents of font files directly,
  /// be aware that the glyph index returned by this function doesn't always
  /// correspond to the internal indices used within the file.  This is done
  /// to ensure that value~0 always corresponds to the 'missing glyph'.
  ///
  /// This function is only meaningful if
  /// a) the font has a variation selector cmap sub table, and
  /// b) the current charmap has a Unicode encoding.
  ///
  /// @since:
  /// 2.3.6
  int FT_Face_GetCharVariantIndex(
    FT_Face face,
    int charcode,
    int variantSelector,
  ) {
    return _FT_Face_GetCharVariantIndex(
      face,
      charcode,
      variantSelector,
    );
  }

  late final _FT_Face_GetCharVariantIndexPtr = _lookup<
          ffi.NativeFunction<FT_UInt Function(FT_Face, FT_ULong, FT_ULong)>>(
      'FT_Face_GetCharVariantIndex');
  late final _FT_Face_GetCharVariantIndex = _FT_Face_GetCharVariantIndexPtr
      .asFunction<int Function(FT_Face, int, int)>();

  /// @function:
  /// FT_Face_GetCharVariantIsDefault
  ///
  /// @description:
  /// Check whether this variation of this Unicode character is the one to
  /// be found in the charmap.
  ///
  /// @input:
  /// face ::
  /// A handle to the source face object.
  ///
  /// charcode ::
  /// The character codepoint in Unicode.
  ///
  /// variantSelector ::
  /// The Unicode codepoint of the variation selector.
  ///
  /// @return:
  /// 1~if found in the standard (Unicode) cmap, 0~if found in the variation
  /// selector cmap, or -1 if it is not a variation.
  ///
  /// @note:
  /// This function is only meaningful if the font has a variation selector
  /// cmap subtable.
  ///
  /// @since:
  /// 2.3.6
  int FT_Face_GetCharVariantIsDefault(
    FT_Face face,
    int charcode,
    int variantSelector,
  ) {
    return _FT_Face_GetCharVariantIsDefault(
      face,
      charcode,
      variantSelector,
    );
  }

  late final _FT_Face_GetCharVariantIsDefaultPtr =
      _lookup<ffi.NativeFunction<FT_Int Function(FT_Face, FT_ULong, FT_ULong)>>(
          'FT_Face_GetCharVariantIsDefault');
  late final _FT_Face_GetCharVariantIsDefault =
      _FT_Face_GetCharVariantIsDefaultPtr.asFunction<
          int Function(FT_Face, int, int)>();

  /// @function:
  /// FT_Face_GetVariantSelectors
  ///
  /// @description:
  /// Return a zero-terminated list of Unicode variation selectors found in
  /// the font.
  ///
  /// @input:
  /// face ::
  /// A handle to the source face object.
  ///
  /// @return:
  /// A pointer to an array of selector code points, or `NULL` if there is
  /// no valid variation selector cmap subtable.
  ///
  /// @note:
  /// The last item in the array is~0; the array is owned by the @FT_Face
  /// object but can be overwritten or released on the next call to a
  /// FreeType function.
  ///
  /// @since:
  /// 2.3.6
  ffi.Pointer<FT_UInt32> FT_Face_GetVariantSelectors(
    FT_Face face,
  ) {
    return _FT_Face_GetVariantSelectors(
      face,
    );
  }

  late final _FT_Face_GetVariantSelectorsPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<FT_UInt32> Function(FT_Face)>>(
          'FT_Face_GetVariantSelectors');
  late final _FT_Face_GetVariantSelectors = _FT_Face_GetVariantSelectorsPtr
      .asFunction<ffi.Pointer<FT_UInt32> Function(FT_Face)>();

  /// @function:
  /// FT_Face_GetVariantsOfChar
  ///
  /// @description:
  /// Return a zero-terminated list of Unicode variation selectors found for
  /// the specified character code.
  ///
  /// @input:
  /// face ::
  /// A handle to the source face object.
  ///
  /// charcode ::
  /// The character codepoint in Unicode.
  ///
  /// @return:
  /// A pointer to an array of variation selector code points that are
  /// active for the given character, or `NULL` if the corresponding list is
  /// empty.
  ///
  /// @note:
  /// The last item in the array is~0; the array is owned by the @FT_Face
  /// object but can be overwritten or released on the next call to a
  /// FreeType function.
  ///
  /// @since:
  /// 2.3.6
  ffi.Pointer<FT_UInt32> FT_Face_GetVariantsOfChar(
    FT_Face face,
    int charcode,
  ) {
    return _FT_Face_GetVariantsOfChar(
      face,
      charcode,
    );
  }

  late final _FT_Face_GetVariantsOfCharPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FT_UInt32> Function(
              FT_Face, FT_ULong)>>('FT_Face_GetVariantsOfChar');
  late final _FT_Face_GetVariantsOfChar = _FT_Face_GetVariantsOfCharPtr
      .asFunction<ffi.Pointer<FT_UInt32> Function(FT_Face, int)>();

  /// @function:
  /// FT_Face_GetCharsOfVariant
  ///
  /// @description:
  /// Return a zero-terminated list of Unicode character codes found for the
  /// specified variation selector.
  ///
  /// @input:
  /// face ::
  /// A handle to the source face object.
  ///
  /// variantSelector ::
  /// The variation selector code point in Unicode.
  ///
  /// @return:
  /// A list of all the code points that are specified by this selector
  /// (both default and non-default codes are returned) or `NULL` if there
  /// is no valid cmap or the variation selector is invalid.
  ///
  /// @note:
  /// The last item in the array is~0; the array is owned by the @FT_Face
  /// object but can be overwritten or released on the next call to a
  /// FreeType function.
  ///
  /// @since:
  /// 2.3.6
  ffi.Pointer<FT_UInt32> FT_Face_GetCharsOfVariant(
    FT_Face face,
    int variantSelector,
  ) {
    return _FT_Face_GetCharsOfVariant(
      face,
      variantSelector,
    );
  }

  late final _FT_Face_GetCharsOfVariantPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FT_UInt32> Function(
              FT_Face, FT_ULong)>>('FT_Face_GetCharsOfVariant');
  late final _FT_Face_GetCharsOfVariant = _FT_Face_GetCharsOfVariantPtr
      .asFunction<ffi.Pointer<FT_UInt32> Function(FT_Face, int)>();

  /// @function:
  /// FT_MulDiv
  ///
  /// @description:
  /// Compute `(a*b)/c` with maximum accuracy, using a 64-bit intermediate
  /// integer whenever necessary.
  ///
  /// This function isn't necessarily as fast as some processor-specific
  /// operations, but is at least completely portable.
  ///
  /// @input:
  /// a ::
  /// The first multiplier.
  ///
  /// b ::
  /// The second multiplier.
  ///
  /// c ::
  /// The divisor.
  ///
  /// @return:
  /// The result of `(a*b)/c`.  This function never traps when trying to
  /// divide by zero; it simply returns 'MaxInt' or 'MinInt' depending on
  /// the signs of `a` and `b`.
  int FT_MulDiv(
    int a,
    int b,
    int c,
  ) {
    return _FT_MulDiv(
      a,
      b,
      c,
    );
  }

  late final _FT_MulDivPtr =
      _lookup<ffi.NativeFunction<FT_Long Function(FT_Long, FT_Long, FT_Long)>>(
          'FT_MulDiv');
  late final _FT_MulDiv =
      _FT_MulDivPtr.asFunction<int Function(int, int, int)>();

  /// @function:
  /// FT_MulFix
  ///
  /// @description:
  /// Compute `(a*b)/0x10000` with maximum accuracy.  Its main use is to
  /// multiply a given value by a 16.16 fixed-point factor.
  ///
  /// @input:
  /// a ::
  /// The first multiplier.
  ///
  /// b ::
  /// The second multiplier.  Use a 16.16 factor here whenever possible
  /// (see note below).
  ///
  /// @return:
  /// The result of `(a*b)/0x10000`.
  ///
  /// @note:
  /// This function has been optimized for the case where the absolute value
  /// of `a` is less than 2048, and `b` is a 16.16 scaling factor.  As this
  /// happens mainly when scaling from notional units to fractional pixels
  /// in FreeType, it resulted in noticeable speed improvements between
  /// versions 2.x and 1.x.
  ///
  /// As a conclusion, always try to place a 16.16 factor as the _second_
  /// argument of this function; this can make a great difference.
  int FT_MulFix(
    int a,
    int b,
  ) {
    return _FT_MulFix(
      a,
      b,
    );
  }

  late final _FT_MulFixPtr =
      _lookup<ffi.NativeFunction<FT_Long Function(FT_Long, FT_Long)>>(
          'FT_MulFix');
  late final _FT_MulFix = _FT_MulFixPtr.asFunction<int Function(int, int)>();

  /// @function:
  /// FT_DivFix
  ///
  /// @description:
  /// Compute `(a*0x10000)/b` with maximum accuracy.  Its main use is to
  /// divide a given value by a 16.16 fixed-point factor.
  ///
  /// @input:
  /// a ::
  /// The numerator.
  ///
  /// b ::
  /// The denominator.  Use a 16.16 factor here.
  ///
  /// @return:
  /// The result of `(a*0x10000)/b`.
  int FT_DivFix(
    int a,
    int b,
  ) {
    return _FT_DivFix(
      a,
      b,
    );
  }

  late final _FT_DivFixPtr =
      _lookup<ffi.NativeFunction<FT_Long Function(FT_Long, FT_Long)>>(
          'FT_DivFix');
  late final _FT_DivFix = _FT_DivFixPtr.asFunction<int Function(int, int)>();

  /// @function:
  /// FT_RoundFix
  ///
  /// @description:
  /// Round a 16.16 fixed number.
  ///
  /// @input:
  /// a ::
  /// The number to be rounded.
  ///
  /// @return:
  /// `a` rounded to the nearest 16.16 fixed integer, halfway cases away
  /// from zero.
  ///
  /// @note:
  /// The function uses wrap-around arithmetic.
  int FT_RoundFix(
    int a,
  ) {
    return _FT_RoundFix(
      a,
    );
  }

  late final _FT_RoundFixPtr =
      _lookup<ffi.NativeFunction<FT_Fixed Function(FT_Fixed)>>('FT_RoundFix');
  late final _FT_RoundFix = _FT_RoundFixPtr.asFunction<int Function(int)>();

  /// @function:
  /// FT_CeilFix
  ///
  /// @description:
  /// Compute the smallest following integer of a 16.16 fixed number.
  ///
  /// @input:
  /// a ::
  /// The number for which the ceiling function is to be computed.
  ///
  /// @return:
  /// `a` rounded towards plus infinity.
  ///
  /// @note:
  /// The function uses wrap-around arithmetic.
  int FT_CeilFix(
    int a,
  ) {
    return _FT_CeilFix(
      a,
    );
  }

  late final _FT_CeilFixPtr =
      _lookup<ffi.NativeFunction<FT_Fixed Function(FT_Fixed)>>('FT_CeilFix');
  late final _FT_CeilFix = _FT_CeilFixPtr.asFunction<int Function(int)>();

  /// @function:
  /// FT_FloorFix
  ///
  /// @description:
  /// Compute the largest previous integer of a 16.16 fixed number.
  ///
  /// @input:
  /// a ::
  /// The number for which the floor function is to be computed.
  ///
  /// @return:
  /// `a` rounded towards minus infinity.
  int FT_FloorFix(
    int a,
  ) {
    return _FT_FloorFix(
      a,
    );
  }

  late final _FT_FloorFixPtr =
      _lookup<ffi.NativeFunction<FT_Fixed Function(FT_Fixed)>>('FT_FloorFix');
  late final _FT_FloorFix = _FT_FloorFixPtr.asFunction<int Function(int)>();

  /// @function:
  /// FT_Vector_Transform
  ///
  /// @description:
  /// Transform a single vector through a 2x2 matrix.
  ///
  /// @inout:
  /// vector ::
  /// The target vector to transform.
  ///
  /// @input:
  /// matrix ::
  /// A pointer to the source 2x2 matrix.
  ///
  /// @note:
  /// The result is undefined if either `vector` or `matrix` is invalid.
  void FT_Vector_Transform(
    ffi.Pointer<FT_Vector> vector,
    ffi.Pointer<FT_Matrix> matrix,
  ) {
    return _FT_Vector_Transform(
      vector,
      matrix,
    );
  }

  late final _FT_Vector_TransformPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FT_Vector>,
              ffi.Pointer<FT_Matrix>)>>('FT_Vector_Transform');
  late final _FT_Vector_Transform = _FT_Vector_TransformPtr.asFunction<
      void Function(ffi.Pointer<FT_Vector>, ffi.Pointer<FT_Matrix>)>();

  /// @function:
  /// FT_Library_Version
  ///
  /// @description:
  /// Return the version of the FreeType library being used.  This is useful
  /// when dynamically linking to the library, since one cannot use the
  /// macros @FREETYPE_MAJOR, @FREETYPE_MINOR, and @FREETYPE_PATCH.
  ///
  /// @input:
  /// library ::
  /// A source library handle.
  ///
  /// @output:
  /// amajor ::
  /// The major version number.
  ///
  /// aminor ::
  /// The minor version number.
  ///
  /// apatch ::
  /// The patch version number.
  ///
  /// @note:
  /// The reason why this function takes a `library` argument is because
  /// certain programs implement library initialization in a custom way that
  /// doesn't use @FT_Init_FreeType.
  ///
  /// In such cases, the library version might not be available before the
  /// library object has been created.
  void FT_Library_Version(
    FT_Library library1,
    ffi.Pointer<FT_Int> amajor,
    ffi.Pointer<FT_Int> aminor,
    ffi.Pointer<FT_Int> apatch,
  ) {
    return _FT_Library_Version(
      library1,
      amajor,
      aminor,
      apatch,
    );
  }

  late final _FT_Library_VersionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(FT_Library, ffi.Pointer<FT_Int>,
              ffi.Pointer<FT_Int>, ffi.Pointer<FT_Int>)>>('FT_Library_Version');
  late final _FT_Library_Version = _FT_Library_VersionPtr.asFunction<
      void Function(FT_Library, ffi.Pointer<FT_Int>, ffi.Pointer<FT_Int>,
          ffi.Pointer<FT_Int>)>();

  /// @function:
  /// FT_Face_CheckTrueTypePatents
  ///
  /// @description:
  /// Deprecated, does nothing.
  ///
  /// @input:
  /// face ::
  /// A face handle.
  ///
  /// @return:
  /// Always returns false.
  ///
  /// @note:
  /// Since May 2010, TrueType hinting is no longer patented.
  ///
  /// @since:
  /// 2.3.5
  int FT_Face_CheckTrueTypePatents(
    FT_Face face,
  ) {
    return _FT_Face_CheckTrueTypePatents(
      face,
    );
  }

  late final _FT_Face_CheckTrueTypePatentsPtr =
      _lookup<ffi.NativeFunction<FT_Bool Function(FT_Face)>>(
          'FT_Face_CheckTrueTypePatents');
  late final _FT_Face_CheckTrueTypePatents =
      _FT_Face_CheckTrueTypePatentsPtr.asFunction<int Function(FT_Face)>();

  /// @function:
  /// FT_Face_SetUnpatentedHinting
  ///
  /// @description:
  /// Deprecated, does nothing.
  ///
  /// @input:
  /// face ::
  /// A face handle.
  ///
  /// value ::
  /// New boolean setting.
  ///
  /// @return:
  /// Always returns false.
  ///
  /// @note:
  /// Since May 2010, TrueType hinting is no longer patented.
  ///
  /// @since:
  /// 2.3.5
  int FT_Face_SetUnpatentedHinting(
    FT_Face face,
    int value,
  ) {
    return _FT_Face_SetUnpatentedHinting(
      face,
      value,
    );
  }

  late final _FT_Face_SetUnpatentedHintingPtr =
      _lookup<ffi.NativeFunction<FT_Bool Function(FT_Face, FT_Bool)>>(
          'FT_Face_SetUnpatentedHinting');
  late final _FT_Face_SetUnpatentedHinting =
      _FT_Face_SetUnpatentedHintingPtr.asFunction<int Function(FT_Face, int)>();
}

class max_align_t extends ffi.Opaque {}

class __locale_struct extends ffi.Struct {
  @ffi.Array.multi([13])
  external ffi.Array<ffi.Pointer<__locale_data>> __locales;

  external ffi.Pointer<ffi.UnsignedShort> __ctype_b;

  external ffi.Pointer<ffi.Int> __ctype_tolower;

  external ffi.Pointer<ffi.Int> __ctype_toupper;

  @ffi.Array.multi([13])
  external ffi.Array<ffi.Pointer<ffi.Char>> __names;
}

class __locale_data extends ffi.Opaque {}

typedef locale_t = __locale_t;
typedef __locale_t = ffi.Pointer<__locale_struct>;

class __fsid_t extends ffi.Struct {
  @ffi.Array.multi([2])
  external ffi.Array<ffi.Int> __val;
}

class __mbstate_t extends ffi.Struct {
  @ffi.Int()
  external int __count;

  external UnnamedUnion1 __value;
}

class UnnamedUnion1 extends ffi.Union {
  @ffi.UnsignedInt()
  external int __wch;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Char> __wchb;
}

class _G_fpos_t extends ffi.Struct {
  @__off_t()
  external int __pos;

  external __mbstate_t __state;
}

typedef __off_t = ffi.Long;

class _G_fpos64_t extends ffi.Struct {
  @__off64_t()
  external int __pos;

  external __mbstate_t __state;
}

typedef __off64_t = ffi.Long;

class _IO_FILE extends ffi.Struct {
  @ffi.Int()
  external int _flags;

  external ffi.Pointer<ffi.Char> _IO_read_ptr;

  external ffi.Pointer<ffi.Char> _IO_read_end;

  external ffi.Pointer<ffi.Char> _IO_read_base;

  external ffi.Pointer<ffi.Char> _IO_write_base;

  external ffi.Pointer<ffi.Char> _IO_write_ptr;

  external ffi.Pointer<ffi.Char> _IO_write_end;

  external ffi.Pointer<ffi.Char> _IO_buf_base;

  external ffi.Pointer<ffi.Char> _IO_buf_end;

  external ffi.Pointer<ffi.Char> _IO_save_base;

  external ffi.Pointer<ffi.Char> _IO_backup_base;

  external ffi.Pointer<ffi.Char> _IO_save_end;

  external ffi.Pointer<_IO_marker> _markers;

  external ffi.Pointer<_IO_FILE> _chain;

  @ffi.Int()
  external int _fileno;

  @ffi.Int()
  external int _flags2;

  @__off_t()
  external int _old_offset;

  @ffi.UnsignedShort()
  external int _cur_column;

  @ffi.SignedChar()
  external int _vtable_offset;

  @ffi.Array.multi([1])
  external ffi.Array<ffi.Char> _shortbuf;

  external ffi.Pointer<_IO_lock_t> _lock;

  @__off64_t()
  external int _offset;

  external ffi.Pointer<_IO_codecvt> _codecvt;

  external ffi.Pointer<_IO_wide_data> _wide_data;

  external ffi.Pointer<_IO_FILE> _freeres_list;

  external ffi.Pointer<ffi.Void> _freeres_buf;

  @ffi.Size()
  external int __pad5;

  @ffi.Int()
  external int _mode;

  @ffi.Array.multi([20])
  external ffi.Array<ffi.Char> _unused2;
}

class _IO_marker extends ffi.Opaque {}

typedef _IO_lock_t = ffi.Void;

class _IO_codecvt extends ffi.Opaque {}

class _IO_wide_data extends ffi.Opaque {}

typedef FILE = _IO_FILE;

class __va_list_tag extends ffi.Struct {
  @ffi.UnsignedInt()
  external int gp_offset;

  @ffi.UnsignedInt()
  external int fp_offset;

  external ffi.Pointer<ffi.Void> overflow_arg_area;

  external ffi.Pointer<ffi.Void> reg_save_area;
}

typedef __ssize_t = ffi.Long;
typedef fpos_t = __fpos_t;
typedef __fpos_t = _G_fpos_t;

class div_t extends ffi.Struct {
  @ffi.Int()
  external int quot;

  @ffi.Int()
  external int rem;
}

class ldiv_t extends ffi.Struct {
  @ffi.Long()
  external int quot;

  @ffi.Long()
  external int rem;
}

class lldiv_t extends ffi.Struct {
  @ffi.LongLong()
  external int quot;

  @ffi.LongLong()
  external int rem;
}

class __sigset_t extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.UnsignedLong> __val;
}

class timeval extends ffi.Struct {
  @__time_t()
  external int tv_sec;

  @__suseconds_t()
  external int tv_usec;
}

typedef __time_t = ffi.Long;
typedef __suseconds_t = ffi.Long;

class timespec extends ffi.Struct {
  @__time_t()
  external int tv_sec;

  @__syscall_slong_t()
  external int tv_nsec;
}

typedef __syscall_slong_t = ffi.Long;

class fd_set extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__fd_mask> __fds_bits;
}

typedef __fd_mask = ffi.Long;

class __atomic_wide_counter extends ffi.Union {
  @ffi.UnsignedLongLong()
  external int __value64;

  external UnnamedStruct1 __value32;
}

class UnnamedStruct1 extends ffi.Struct {
  @ffi.UnsignedInt()
  external int __low;

  @ffi.UnsignedInt()
  external int __high;
}

class __pthread_internal_list extends ffi.Struct {
  external ffi.Pointer<__pthread_internal_list> __prev;

  external ffi.Pointer<__pthread_internal_list> __next;
}

class __pthread_internal_slist extends ffi.Struct {
  external ffi.Pointer<__pthread_internal_slist> __next;
}

class __pthread_mutex_s extends ffi.Struct {
  @ffi.Int()
  external int __lock;

  @ffi.UnsignedInt()
  external int __count;

  @ffi.Int()
  external int __owner;

  @ffi.UnsignedInt()
  external int __nusers;

  @ffi.Int()
  external int __kind;

  @ffi.Short()
  external int __spins;

  @ffi.Short()
  external int __elision;

  external __pthread_list_t __list;
}

typedef __pthread_list_t = __pthread_internal_list;

class __pthread_rwlock_arch_t extends ffi.Struct {
  @ffi.UnsignedInt()
  external int __readers;

  @ffi.UnsignedInt()
  external int __writers;

  @ffi.UnsignedInt()
  external int __wrphase_futex;

  @ffi.UnsignedInt()
  external int __writers_futex;

  @ffi.UnsignedInt()
  external int __pad3;

  @ffi.UnsignedInt()
  external int __pad4;

  @ffi.Int()
  external int __cur_writer;

  @ffi.Int()
  external int __shared;

  @ffi.SignedChar()
  external int __rwelision;

  @ffi.Array.multi([7])
  external ffi.Array<ffi.UnsignedChar> __pad1;

  @ffi.UnsignedLong()
  external int __pad2;

  @ffi.UnsignedInt()
  external int __flags;
}

class __pthread_cond_s extends ffi.Struct {
  external __atomic_wide_counter __wseq;

  external __atomic_wide_counter __g1_start;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.UnsignedInt> __g_refs;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.UnsignedInt> __g_size;

  @ffi.UnsignedInt()
  external int __g1_orig_size;

  @ffi.UnsignedInt()
  external int __wrefs;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.UnsignedInt> __g_signals;
}

class __once_flag extends ffi.Struct {
  @ffi.Int()
  external int __data;
}

class pthread_mutexattr_t extends ffi.Union {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Char> __size;

  @ffi.Int()
  external int __align;
}

class pthread_condattr_t extends ffi.Union {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Char> __size;

  @ffi.Int()
  external int __align;
}

class pthread_attr_t extends ffi.Union {
  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __size;

  @ffi.Long()
  external int __align;
}

class pthread_mutex_t extends ffi.Union {
  external __pthread_mutex_s __data;

  @ffi.Array.multi([40])
  external ffi.Array<ffi.Char> __size;

  @ffi.Long()
  external int __align;
}

class pthread_cond_t extends ffi.Union {
  external __pthread_cond_s __data;

  @ffi.Array.multi([48])
  external ffi.Array<ffi.Char> __size;

  @ffi.LongLong()
  external int __align;
}

class pthread_rwlock_t extends ffi.Union {
  external __pthread_rwlock_arch_t __data;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __size;

  @ffi.Long()
  external int __align;
}

class pthread_rwlockattr_t extends ffi.Union {
  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __size;

  @ffi.Long()
  external int __align;
}

class pthread_barrier_t extends ffi.Union {
  @ffi.Array.multi([32])
  external ffi.Array<ffi.Char> __size;

  @ffi.Long()
  external int __align;
}

class pthread_barrierattr_t extends ffi.Union {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Char> __size;

  @ffi.Int()
  external int __align;
}

class random_data extends ffi.Struct {
  external ffi.Pointer<ffi.Int32> fptr;

  external ffi.Pointer<ffi.Int32> rptr;

  external ffi.Pointer<ffi.Int32> state;

  @ffi.Int()
  external int rand_type;

  @ffi.Int()
  external int rand_deg;

  @ffi.Int()
  external int rand_sep;

  external ffi.Pointer<ffi.Int32> end_ptr;
}

class drand48_data extends ffi.Struct {
  @ffi.Array.multi([3])
  external ffi.Array<ffi.UnsignedShort> __x;

  @ffi.Array.multi([3])
  external ffi.Array<ffi.UnsignedShort> __old_x;

  @ffi.UnsignedShort()
  external int __c;

  @ffi.UnsignedShort()
  external int __init;

  @ffi.UnsignedLongLong()
  external int __a;
}

typedef __uint32_t = ffi.UnsignedInt;
typedef __compar_fn_t = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>;

class __jmp_buf_tag extends ffi.Struct {
  @ffi.Array.multi([8])
  external ffi.Array<ffi.Long> __jmpbuf;

  @ffi.Int()
  external int __mask_was_saved;

  external __sigset_t __saved_mask;
}

/// @struct:
/// FT_MemoryRec
///
/// @description:
/// A structure used to describe a given memory manager to FreeType~2.
///
/// @fields:
/// user ::
/// A generic typeless pointer for user data.
///
/// alloc ::
/// A pointer type to an allocation function.
///
/// free ::
/// A pointer type to an memory freeing function.
///
/// realloc ::
/// A pointer type to a reallocation function.
class FT_MemoryRec_ extends ffi.Struct {
  external ffi.Pointer<ffi.Void> user;

  external FT_Alloc_Func alloc;

  external FT_Free_Func free;

  external FT_Realloc_Func realloc;
}

/// @functype:
/// FT_Alloc_Func
///
/// @description:
/// A function used to allocate `size` bytes from `memory`.
///
/// @input:
/// memory ::
/// A handle to the source memory manager.
///
/// size ::
/// The size in bytes to allocate.
///
/// @return:
/// Address of new memory block.  0~in case of failure.
typedef FT_Alloc_Func = ffi.Pointer<
    ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(FT_Memory, ffi.Long)>>;

/// @type:
/// FT_Memory
///
/// @description:
/// A handle to a given memory manager object, defined with an
/// @FT_MemoryRec structure.
typedef FT_Memory = ffi.Pointer<FT_MemoryRec_>;

/// @functype:
/// FT_Free_Func
///
/// @description:
/// A function used to release a given block of memory.
///
/// @input:
/// memory ::
/// A handle to the source memory manager.
///
/// block ::
/// The address of the target memory block.
typedef FT_Free_Func = ffi.Pointer<
    ffi.NativeFunction<ffi.Void Function(FT_Memory, ffi.Pointer<ffi.Void>)>>;

/// @functype:
/// FT_Realloc_Func
///
/// @description:
/// A function used to re-allocate a given block of memory.
///
/// @input:
/// memory ::
/// A handle to the source memory manager.
///
/// cur_size ::
/// The block's current size in bytes.
///
/// new_size ::
/// The block's requested new size.
///
/// block ::
/// The block's current address.
///
/// @return:
/// New block address.  0~in case of memory shortage.
///
/// @note:
/// In case of error, the old block must still be available.
typedef FT_Realloc_Func = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Pointer<ffi.Void> Function(
            FT_Memory, ffi.Long, ffi.Long, ffi.Pointer<ffi.Void>)>>;

/// @struct:
/// FT_StreamRec
///
/// @description:
/// A structure used to describe an input stream.
///
/// @input:
/// base ::
/// For memory-based streams, this is the address of the first stream
/// byte in memory.  This field should always be set to `NULL` for
/// disk-based streams.
///
/// size ::
/// The stream size in bytes.
///
/// In case of compressed streams where the size is unknown before
/// actually doing the decompression, the value is set to 0x7FFFFFFF.
/// (Note that this size value can occur for normal streams also; it is
/// thus just a hint.)
///
/// pos ::
/// The current position within the stream.
///
/// descriptor ::
/// This field is a union that can hold an integer or a pointer.  It is
/// used by stream implementations to store file descriptors or `FILE*`
/// pointers.
///
/// pathname ::
/// This field is completely ignored by FreeType.  However, it is often
/// useful during debugging to use it to store the stream's filename
/// (where available).
///
/// read ::
/// The stream's input function.
///
/// close ::
/// The stream's close function.
///
/// memory ::
/// The memory manager to use to preload frames.  This is set internally
/// by FreeType and shouldn't be touched by stream implementations.
///
/// cursor ::
/// This field is set and used internally by FreeType when parsing
/// frames.  In particular, the `FT_GET_XXX` macros use this instead of
/// the `pos` field.
///
/// limit ::
/// This field is set and used internally by FreeType when parsing
/// frames.
class FT_StreamRec_ extends ffi.Struct {
  external ffi.Pointer<ffi.UnsignedChar> base;

  @ffi.UnsignedLong()
  external int size;

  @ffi.UnsignedLong()
  external int pos;

  external FT_StreamDesc descriptor;

  external FT_StreamDesc pathname;

  external FT_Stream_IoFunc read;

  external FT_Stream_CloseFunc close;

  external FT_Memory memory;

  external ffi.Pointer<ffi.UnsignedChar> cursor;

  external ffi.Pointer<ffi.UnsignedChar> limit;
}

/// @struct:
/// FT_StreamDesc
///
/// @description:
/// A union type used to store either a long or a pointer.  This is used
/// to store a file descriptor or a `FILE*` in an input stream.
typedef FT_StreamDesc = FT_StreamDesc_;

/// @struct:
/// FT_StreamDesc
///
/// @description:
/// A union type used to store either a long or a pointer.  This is used
/// to store a file descriptor or a `FILE*` in an input stream.
class FT_StreamDesc_ extends ffi.Union {
  @ffi.Long()
  external int value;

  external ffi.Pointer<ffi.Void> pointer;
}

/// @functype:
/// FT_Stream_IoFunc
///
/// @description:
/// A function used to seek and read data from a given input stream.
///
/// @input:
/// stream ::
/// A handle to the source stream.
///
/// offset ::
/// The offset from the start of the stream to seek to if this is a seek
/// operation (see note).
///
/// buffer ::
/// The address of the read buffer.
///
/// count ::
/// The number of bytes to read from the stream.
///
/// @return:
/// The number of bytes effectively read by the stream.
///
/// @note:
/// This function performs a seek *or* a read operation depending on the
/// argument values.  If `count` is zero, the operation is a seek to
/// `offset` bytes.  If `count` is >~0, the operation is a read of `count`
/// bytes from the current position in the stream, and the `offset` value
/// should be ignored.
///
/// For seek operations, a non-zero return value indicates an error.
typedef FT_Stream_IoFunc = ffi.Pointer<
    ffi.NativeFunction<
        ffi.UnsignedLong Function(FT_Stream, ffi.UnsignedLong,
            ffi.Pointer<ffi.UnsignedChar>, ffi.UnsignedLong)>>;

/// @type:
/// FT_Stream
///
/// @description:
/// A handle to an input stream.
///
/// @also:
/// See @FT_StreamRec for the publicly accessible fields of a given stream
/// object.
typedef FT_Stream = ffi.Pointer<FT_StreamRec_>;

/// @functype:
/// FT_Stream_CloseFunc
///
/// @description:
/// A function used to close a given input stream.
///
/// @input:
/// stream ::
/// A handle to the target stream.
typedef FT_Stream_CloseFunc
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function(FT_Stream)>>;

/// @struct:
/// FT_Vector
///
/// @description:
/// A simple structure used to store a 2D vector; coordinates are of the
/// FT_Pos type.
///
/// @fields:
/// x ::
/// The horizontal coordinate.
/// y ::
/// The vertical coordinate.
class FT_Vector_ extends ffi.Struct {
  @FT_Pos()
  external int x;

  @FT_Pos()
  external int y;
}

/// @type:
/// FT_Pos
///
/// @description:
/// The type FT_Pos is used to store vectorial coordinates.  Depending on
/// the context, these can represent distances in integer font units, or
/// 16.16, or 26.6 fixed-point pixel coordinates.
typedef FT_Pos = ffi.Long;

/// @struct:
/// FT_BBox
///
/// @description:
/// A structure used to hold an outline's bounding box, i.e., the
/// coordinates of its extrema in the horizontal and vertical directions.
///
/// @fields:
/// xMin ::
/// The horizontal minimum (left-most).
///
/// yMin ::
/// The vertical minimum (bottom-most).
///
/// xMax ::
/// The horizontal maximum (right-most).
///
/// yMax ::
/// The vertical maximum (top-most).
///
/// @note:
/// The bounding box is specified with the coordinates of the lower left
/// and the upper right corner.  In PostScript, those values are often
/// called (llx,lly) and (urx,ury), respectively.
///
/// If `yMin` is negative, this value gives the glyph's descender.
/// Otherwise, the glyph doesn't descend below the baseline.  Similarly,
/// if `ymax` is positive, this value gives the glyph's ascender.
///
/// `xMin` gives the horizontal distance from the glyph's origin to the
/// left edge of the glyph's bounding box.  If `xMin` is negative, the
/// glyph extends to the left of the origin.
class FT_BBox_ extends ffi.Struct {
  @FT_Pos()
  external int xMin;

  @FT_Pos()
  external int yMin;

  @FT_Pos()
  external int xMax;

  @FT_Pos()
  external int yMax;
}

/// @enum:
/// FT_Pixel_Mode
///
/// @description:
/// An enumeration type used to describe the format of pixels in a given
/// bitmap.  Note that additional formats may be added in the future.
///
/// @values:
/// FT_PIXEL_MODE_NONE ::
/// Value~0 is reserved.
///
/// FT_PIXEL_MODE_MONO ::
/// A monochrome bitmap, using 1~bit per pixel.  Note that pixels are
/// stored in most-significant order (MSB), which means that the
/// left-most pixel in a byte has value 128.
///
/// FT_PIXEL_MODE_GRAY ::
/// An 8-bit bitmap, generally used to represent anti-aliased glyph
/// images.  Each pixel is stored in one byte.  Note that the number of
/// 'gray' levels is stored in the `num_grays` field of the @FT_Bitmap
/// structure (it generally is 256).
///
/// FT_PIXEL_MODE_GRAY2 ::
/// A 2-bit per pixel bitmap, used to represent embedded anti-aliased
/// bitmaps in font files according to the OpenType specification.  We
/// haven't found a single font using this format, however.
///
/// FT_PIXEL_MODE_GRAY4 ::
/// A 4-bit per pixel bitmap, representing embedded anti-aliased bitmaps
/// in font files according to the OpenType specification.  We haven't
/// found a single font using this format, however.
///
/// FT_PIXEL_MODE_LCD ::
/// An 8-bit bitmap, representing RGB or BGR decimated glyph images used
/// for display on LCD displays; the bitmap is three times wider than
/// the original glyph image.  See also @FT_RENDER_MODE_LCD.
///
/// FT_PIXEL_MODE_LCD_V ::
/// An 8-bit bitmap, representing RGB or BGR decimated glyph images used
/// for display on rotated LCD displays; the bitmap is three times
/// taller than the original glyph image.  See also
/// @FT_RENDER_MODE_LCD_V.
///
/// FT_PIXEL_MODE_BGRA ::
/// [Since 2.5] An image with four 8-bit channels per pixel,
/// representing a color image (such as emoticons) with alpha channel.
/// For each pixel, the format is BGRA, which means, the blue channel
/// comes first in memory.  The color channels are pre-multiplied and in
/// the sRGB colorspace.  For example, full red at half-translucent
/// opacity will be represented as '00,00,80,80', not '00,00,FF,80'.
/// See also @FT_LOAD_COLOR.
abstract class FT_Pixel_Mode_ {
  static const int FT_PIXEL_MODE_NONE = 0;
  static const int FT_PIXEL_MODE_MONO = 1;
  static const int FT_PIXEL_MODE_GRAY = 2;
  static const int FT_PIXEL_MODE_GRAY2 = 3;
  static const int FT_PIXEL_MODE_GRAY4 = 4;
  static const int FT_PIXEL_MODE_LCD = 5;
  static const int FT_PIXEL_MODE_LCD_V = 6;
  static const int FT_PIXEL_MODE_BGRA = 7;
  static const int FT_PIXEL_MODE_MAX = 8;
}

/// @struct:
/// FT_Bitmap
///
/// @description:
/// A structure used to describe a bitmap or pixmap to the raster.  Note
/// that we now manage pixmaps of various depths through the `pixel_mode`
/// field.
///
/// @fields:
/// rows ::
/// The number of bitmap rows.
///
/// width ::
/// The number of pixels in bitmap row.
///
/// pitch ::
/// The pitch's absolute value is the number of bytes taken by one
/// bitmap row, including padding.  However, the pitch is positive when
/// the bitmap has a 'down' flow, and negative when it has an 'up' flow.
/// In all cases, the pitch is an offset to add to a bitmap pointer in
/// order to go down one row.
///
/// Note that 'padding' means the alignment of a bitmap to a byte
/// border, and FreeType functions normally align to the smallest
/// possible integer value.
///
/// For the B/W rasterizer, `pitch` is always an even number.
///
/// To change the pitch of a bitmap (say, to make it a multiple of 4),
/// use @FT_Bitmap_Convert.  Alternatively, you might use callback
/// functions to directly render to the application's surface; see the
/// file `example2.cpp` in the tutorial for a demonstration.
///
/// buffer ::
/// A typeless pointer to the bitmap buffer.  This value should be
/// aligned on 32-bit boundaries in most cases.
///
/// num_grays ::
/// This field is only used with @FT_PIXEL_MODE_GRAY; it gives the
/// number of gray levels used in the bitmap.
///
/// pixel_mode ::
/// The pixel mode, i.e., how pixel bits are stored.  See @FT_Pixel_Mode
/// for possible values.
///
/// palette_mode ::
/// This field is intended for paletted pixel modes; it indicates how
/// the palette is stored.  Not used currently.
///
/// palette ::
/// A typeless pointer to the bitmap palette; this field is intended for
/// paletted pixel modes.  Not used currently.
class FT_Bitmap_ extends ffi.Struct {
  @ffi.UnsignedInt()
  external int rows;

  @ffi.UnsignedInt()
  external int width;

  @ffi.Int()
  external int pitch;

  external ffi.Pointer<ffi.UnsignedChar> buffer;

  @ffi.UnsignedShort()
  external int num_grays;

  @ffi.UnsignedChar()
  external int pixel_mode;

  @ffi.UnsignedChar()
  external int palette_mode;

  external ffi.Pointer<ffi.Void> palette;
}

/// @struct:
/// FT_Outline
///
/// @description:
/// This structure is used to describe an outline to the scan-line
/// converter.
///
/// @fields:
/// n_contours ::
/// The number of contours in the outline.
///
/// n_points ::
/// The number of points in the outline.
///
/// points ::
/// A pointer to an array of `n_points` @FT_Vector elements, giving the
/// outline's point coordinates.
///
/// tags ::
/// A pointer to an array of `n_points` chars, giving each outline
/// point's type.
///
/// If bit~0 is unset, the point is 'off' the curve, i.e., a Bezier
/// control point, while it is 'on' if set.
///
/// Bit~1 is meaningful for 'off' points only.  If set, it indicates a
/// third-order Bezier arc control point; and a second-order control
/// point if unset.
///
/// If bit~2 is set, bits 5-7 contain the drop-out mode (as defined in
/// the OpenType specification; the value is the same as the argument to
/// the 'SCANMODE' instruction).
///
/// Bits 3 and~4 are reserved for internal purposes.
///
/// contours ::
/// An array of `n_contours` shorts, giving the end point of each
/// contour within the outline.  For example, the first contour is
/// defined by the points '0' to `contours[0]`, the second one is
/// defined by the points `contours[0]+1` to `contours[1]`, etc.
///
/// flags ::
/// A set of bit flags used to characterize the outline and give hints
/// to the scan-converter and hinter on how to convert/grid-fit it.  See
/// @FT_OUTLINE_XXX.
///
/// @note:
/// The B/W rasterizer only checks bit~2 in the `tags` array for the first
/// point of each contour.  The drop-out mode as given with
/// @FT_OUTLINE_IGNORE_DROPOUTS, @FT_OUTLINE_SMART_DROPOUTS, and
/// @FT_OUTLINE_INCLUDE_STUBS in `flags` is then overridden.
class FT_Outline_ extends ffi.Struct {
  @ffi.Short()
  external int n_contours;

  @ffi.Short()
  external int n_points;

  external ffi.Pointer<FT_Vector> points;

  external ffi.Pointer<ffi.Char> tags;

  external ffi.Pointer<ffi.Short> contours;

  @ffi.Int()
  external int flags;
}

/// @struct:
/// FT_Vector
///
/// @description:
/// A simple structure used to store a 2D vector; coordinates are of the
/// FT_Pos type.
///
/// @fields:
/// x ::
/// The horizontal coordinate.
/// y ::
/// The vertical coordinate.
typedef FT_Vector = FT_Vector_;

/// @struct:
/// FT_Outline_Funcs
///
/// @description:
/// A structure to hold various function pointers used during outline
/// decomposition in order to emit segments, conic, and cubic Beziers.
///
/// @fields:
/// move_to ::
/// The 'move to' emitter.
///
/// line_to ::
/// The segment emitter.
///
/// conic_to ::
/// The second-order Bezier arc emitter.
///
/// cubic_to ::
/// The third-order Bezier arc emitter.
///
/// shift ::
/// The shift that is applied to coordinates before they are sent to the
/// emitter.
///
/// delta ::
/// The delta that is applied to coordinates before they are sent to the
/// emitter, but after the shift.
///
/// @note:
/// The point coordinates sent to the emitters are the transformed version
/// of the original coordinates (this is important for high accuracy
/// during scan-conversion).  The transformation is simple:
///
/// ```
/// x' = (x << shift) - delta
/// y' = (y << shift) - delta
/// ```
///
/// Set the values of `shift` and `delta` to~0 to get the original point
/// coordinates.
class FT_Outline_Funcs_ extends ffi.Struct {
  external FT_Outline_MoveToFunc move_to;

  external FT_Outline_LineToFunc line_to;

  external FT_Outline_ConicToFunc conic_to;

  external FT_Outline_CubicToFunc cubic_to;

  @ffi.Int()
  external int shift;

  @FT_Pos()
  external int delta;
}

/// @functype:
/// FT_Outline_MoveToFunc
///
/// @description:
/// A function pointer type used to describe the signature of a 'move to'
/// function during outline walking/decomposition.
///
/// A 'move to' is emitted to start a new contour in an outline.
///
/// @input:
/// to ::
/// A pointer to the target point of the 'move to'.
///
/// user ::
/// A typeless pointer, which is passed from the caller of the
/// decomposition function.
///
/// @return:
/// Error code.  0~means success.
typedef FT_Outline_MoveToFunc = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(ffi.Pointer<FT_Vector>, ffi.Pointer<ffi.Void>)>>;

/// @functype:
/// FT_Outline_LineToFunc
///
/// @description:
/// A function pointer type used to describe the signature of a 'line to'
/// function during outline walking/decomposition.
///
/// A 'line to' is emitted to indicate a segment in the outline.
///
/// @input:
/// to ::
/// A pointer to the target point of the 'line to'.
///
/// user ::
/// A typeless pointer, which is passed from the caller of the
/// decomposition function.
///
/// @return:
/// Error code.  0~means success.
typedef FT_Outline_LineToFunc = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(ffi.Pointer<FT_Vector>, ffi.Pointer<ffi.Void>)>>;

/// @functype:
/// FT_Outline_ConicToFunc
///
/// @description:
/// A function pointer type used to describe the signature of a 'conic to'
/// function during outline walking or decomposition.
///
/// A 'conic to' is emitted to indicate a second-order Bezier arc in the
/// outline.
///
/// @input:
/// control ::
/// An intermediate control point between the last position and the new
/// target in `to`.
///
/// to ::
/// A pointer to the target end point of the conic arc.
///
/// user ::
/// A typeless pointer, which is passed from the caller of the
/// decomposition function.
///
/// @return:
/// Error code.  0~means success.
typedef FT_Outline_ConicToFunc = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(ffi.Pointer<FT_Vector>, ffi.Pointer<FT_Vector>,
            ffi.Pointer<ffi.Void>)>>;

/// @functype:
/// FT_Outline_CubicToFunc
///
/// @description:
/// A function pointer type used to describe the signature of a 'cubic to'
/// function during outline walking or decomposition.
///
/// A 'cubic to' is emitted to indicate a third-order Bezier arc.
///
/// @input:
/// control1 ::
/// A pointer to the first Bezier control point.
///
/// control2 ::
/// A pointer to the second Bezier control point.
///
/// to ::
/// A pointer to the target end point.
///
/// user ::
/// A typeless pointer, which is passed from the caller of the
/// decomposition function.
///
/// @return:
/// Error code.  0~means success.
typedef FT_Outline_CubicToFunc = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(ffi.Pointer<FT_Vector>, ffi.Pointer<FT_Vector>,
            ffi.Pointer<FT_Vector>, ffi.Pointer<ffi.Void>)>>;

/// @enum:
/// FT_Glyph_Format
///
/// @description:
/// An enumeration type used to describe the format of a given glyph
/// image.  Note that this version of FreeType only supports two image
/// formats, even though future font drivers will be able to register
/// their own format.
///
/// @values:
/// FT_GLYPH_FORMAT_NONE ::
/// The value~0 is reserved.
///
/// FT_GLYPH_FORMAT_COMPOSITE ::
/// The glyph image is a composite of several other images.  This format
/// is _only_ used with @FT_LOAD_NO_RECURSE, and is used to report
/// compound glyphs (like accented characters).
///
/// FT_GLYPH_FORMAT_BITMAP ::
/// The glyph image is a bitmap, and can be described as an @FT_Bitmap.
/// You generally need to access the `bitmap` field of the
/// @FT_GlyphSlotRec structure to read it.
///
/// FT_GLYPH_FORMAT_OUTLINE ::
/// The glyph image is a vectorial outline made of line segments and
/// Bezier arcs; it can be described as an @FT_Outline; you generally
/// want to access the `outline` field of the @FT_GlyphSlotRec structure
/// to read it.
///
/// FT_GLYPH_FORMAT_PLOTTER ::
/// The glyph image is a vectorial path with no inside and outside
/// contours.  Some Type~1 fonts, like those in the Hershey family,
/// contain glyphs in this format.  These are described as @FT_Outline,
/// but FreeType isn't currently capable of rendering them correctly.
///
/// FT_GLYPH_FORMAT_SVG ::
/// [Since 2.12] The glyph is represented by an SVG document in the
/// 'SVG~' table.
abstract class FT_Glyph_Format_ {
  static const int FT_GLYPH_FORMAT_NONE = 0;
  static const int FT_GLYPH_FORMAT_COMPOSITE = 1668246896;
  static const int FT_GLYPH_FORMAT_BITMAP = 1651078259;
  static const int FT_GLYPH_FORMAT_OUTLINE = 1869968492;
  static const int FT_GLYPH_FORMAT_PLOTTER = 1886154612;
  static const int FT_GLYPH_FORMAT_SVG = 1398163232;
}

/// @struct:
/// FT_Span
///
/// @description:
/// A structure to model a single span of consecutive pixels when
/// rendering an anti-aliased bitmap.
///
/// @fields:
/// x ::
/// The span's horizontal start position.
///
/// len ::
/// The span's length in pixels.
///
/// coverage ::
/// The span color/coverage, ranging from 0 (background) to 255
/// (foreground).
///
/// @note:
/// This structure is used by the span drawing callback type named
/// @FT_SpanFunc that takes the y~coordinate of the span as a parameter.
///
/// The anti-aliased rasterizer produces coverage values from 0 to 255,
/// this is, from completely transparent to completely opaque.
class FT_Span_ extends ffi.Struct {
  @ffi.Short()
  external int x;

  @ffi.UnsignedShort()
  external int len;

  @ffi.UnsignedChar()
  external int coverage;
}

/// @struct:
/// FT_Raster_Params
///
/// @description:
/// A structure to hold the parameters used by a raster's render function,
/// passed as an argument to @FT_Outline_Render.
///
/// @fields:
/// target ::
/// The target bitmap.
///
/// source ::
/// A pointer to the source glyph image (e.g., an @FT_Outline).
///
/// flags ::
/// The rendering flags.
///
/// gray_spans ::
/// The gray span drawing callback.
///
/// black_spans ::
/// Unused.
///
/// bit_test ::
/// Unused.
///
/// bit_set ::
/// Unused.
///
/// user ::
/// User-supplied data that is passed to each drawing callback.
///
/// clip_box ::
/// An optional span clipping box expressed in _integer_ pixels
/// (not in 26.6 fixed-point units).
///
/// @note:
/// The @FT_RASTER_FLAG_AA bit flag must be set in the `flags` to
/// generate an anti-aliased glyph bitmap, otherwise a monochrome bitmap
/// is generated.  The `target` should have appropriate pixel mode and its
/// dimensions define the clipping region.
///
/// If both @FT_RASTER_FLAG_AA and @FT_RASTER_FLAG_DIRECT bit flags
/// are set in `flags`, the raster calls an @FT_SpanFunc callback
/// `gray_spans` with `user` data as an argument ignoring `target`.  This
/// allows direct composition over a pre-existing user surface to perform
/// the span drawing and composition.  To optionally clip the spans, set
/// the @FT_RASTER_FLAG_CLIP flag and `clip_box`.  The monochrome raster
/// does not support the direct mode.
///
/// The gray-level rasterizer always uses 256 gray levels.  If you want
/// fewer gray levels, you have to use @FT_RASTER_FLAG_DIRECT and reduce
/// the levels in the callback function.
class FT_Raster_Params_ extends ffi.Struct {
  external ffi.Pointer<FT_Bitmap> target;

  external ffi.Pointer<ffi.Void> source;

  @ffi.Int()
  external int flags;

  external FT_SpanFunc gray_spans;

  external FT_SpanFunc black_spans;

  external FT_Raster_BitTest_Func bit_test;

  external FT_Raster_BitSet_Func bit_set;

  external ffi.Pointer<ffi.Void> user;

  external FT_BBox clip_box;
}

/// @struct:
/// FT_Bitmap
///
/// @description:
/// A structure used to describe a bitmap or pixmap to the raster.  Note
/// that we now manage pixmaps of various depths through the `pixel_mode`
/// field.
///
/// @fields:
/// rows ::
/// The number of bitmap rows.
///
/// width ::
/// The number of pixels in bitmap row.
///
/// pitch ::
/// The pitch's absolute value is the number of bytes taken by one
/// bitmap row, including padding.  However, the pitch is positive when
/// the bitmap has a 'down' flow, and negative when it has an 'up' flow.
/// In all cases, the pitch is an offset to add to a bitmap pointer in
/// order to go down one row.
///
/// Note that 'padding' means the alignment of a bitmap to a byte
/// border, and FreeType functions normally align to the smallest
/// possible integer value.
///
/// For the B/W rasterizer, `pitch` is always an even number.
///
/// To change the pitch of a bitmap (say, to make it a multiple of 4),
/// use @FT_Bitmap_Convert.  Alternatively, you might use callback
/// functions to directly render to the application's surface; see the
/// file `example2.cpp` in the tutorial for a demonstration.
///
/// buffer ::
/// A typeless pointer to the bitmap buffer.  This value should be
/// aligned on 32-bit boundaries in most cases.
///
/// num_grays ::
/// This field is only used with @FT_PIXEL_MODE_GRAY; it gives the
/// number of gray levels used in the bitmap.
///
/// pixel_mode ::
/// The pixel mode, i.e., how pixel bits are stored.  See @FT_Pixel_Mode
/// for possible values.
///
/// palette_mode ::
/// This field is intended for paletted pixel modes; it indicates how
/// the palette is stored.  Not used currently.
///
/// palette ::
/// A typeless pointer to the bitmap palette; this field is intended for
/// paletted pixel modes.  Not used currently.
typedef FT_Bitmap = FT_Bitmap_;

/// @functype:
/// FT_SpanFunc
///
/// @description:
/// A function used as a call-back by the anti-aliased renderer in order
/// to let client applications draw themselves the pixel spans on each
/// scan line.
///
/// @input:
/// y ::
/// The scanline's upward y~coordinate.
///
/// count ::
/// The number of spans to draw on this scanline.
///
/// spans ::
/// A table of `count` spans to draw on the scanline.
///
/// user ::
/// User-supplied data that is passed to the callback.
///
/// @note:
/// This callback allows client applications to directly render the spans
/// of the anti-aliased bitmap to any kind of surfaces.
///
/// This can be used to write anti-aliased outlines directly to a given
/// background bitmap using alpha compositing.  It can also be used for
/// oversampling and averaging.
typedef FT_SpanFunc = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(
            ffi.Int, ffi.Int, ffi.Pointer<FT_Span>, ffi.Pointer<ffi.Void>)>>;

/// @struct:
/// FT_Span
///
/// @description:
/// A structure to model a single span of consecutive pixels when
/// rendering an anti-aliased bitmap.
///
/// @fields:
/// x ::
/// The span's horizontal start position.
///
/// len ::
/// The span's length in pixels.
///
/// coverage ::
/// The span color/coverage, ranging from 0 (background) to 255
/// (foreground).
///
/// @note:
/// This structure is used by the span drawing callback type named
/// @FT_SpanFunc that takes the y~coordinate of the span as a parameter.
///
/// The anti-aliased rasterizer produces coverage values from 0 to 255,
/// this is, from completely transparent to completely opaque.
typedef FT_Span = FT_Span_;

/// @functype:
/// FT_Raster_BitTest_Func
///
/// @description:
/// Deprecated, unimplemented.
typedef FT_Raster_BitTest_Func = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(ffi.Int, ffi.Int, ffi.Pointer<ffi.Void>)>>;

/// @functype:
/// FT_Raster_BitSet_Func
///
/// @description:
/// Deprecated, unimplemented.
typedef FT_Raster_BitSet_Func = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Int, ffi.Int, ffi.Pointer<ffi.Void>)>>;

/// @struct:
/// FT_BBox
///
/// @description:
/// A structure used to hold an outline's bounding box, i.e., the
/// coordinates of its extrema in the horizontal and vertical directions.
///
/// @fields:
/// xMin ::
/// The horizontal minimum (left-most).
///
/// yMin ::
/// The vertical minimum (bottom-most).
///
/// xMax ::
/// The horizontal maximum (right-most).
///
/// yMax ::
/// The vertical maximum (top-most).
///
/// @note:
/// The bounding box is specified with the coordinates of the lower left
/// and the upper right corner.  In PostScript, those values are often
/// called (llx,lly) and (urx,ury), respectively.
///
/// If `yMin` is negative, this value gives the glyph's descender.
/// Otherwise, the glyph doesn't descend below the baseline.  Similarly,
/// if `ymax` is positive, this value gives the glyph's ascender.
///
/// `xMin` gives the horizontal distance from the glyph's origin to the
/// left edge of the glyph's bounding box.  If `xMin` is negative, the
/// glyph extends to the left of the origin.
typedef FT_BBox = FT_BBox_;

class FT_RasterRec_ extends ffi.Opaque {}

/// @struct:
/// FT_Raster_Funcs
///
/// @description:
/// A structure used to describe a given raster class to the library.
///
/// @fields:
/// glyph_format ::
/// The supported glyph format for this raster.
///
/// raster_new ::
/// The raster constructor.
///
/// raster_reset ::
/// Used to reset the render pool within the raster.
///
/// raster_render ::
/// A function to render a glyph into a given bitmap.
///
/// raster_done ::
/// The raster destructor.
class FT_Raster_Funcs_ extends ffi.Struct {
  @ffi.Int32()
  external int glyph_format;

  external FT_Raster_NewFunc raster_new;

  external FT_Raster_ResetFunc raster_reset;

  external FT_Raster_SetModeFunc raster_set_mode;

  external FT_Raster_RenderFunc raster_render;

  external FT_Raster_DoneFunc raster_done;
}

/// @functype:
/// FT_Raster_NewFunc
///
/// @description:
/// A function used to create a new raster object.
///
/// @input:
/// memory ::
/// A handle to the memory allocator.
///
/// @output:
/// raster ::
/// A handle to the new raster object.
///
/// @return:
/// Error code.  0~means success.
///
/// @note:
/// The `memory` parameter is a typeless pointer in order to avoid
/// un-wanted dependencies on the rest of the FreeType code.  In practice,
/// it is an @FT_Memory object, i.e., a handle to the standard FreeType
/// memory allocator.  However, this field can be completely ignored by a
/// given raster implementation.
typedef FT_Raster_NewFunc = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<FT_Raster>)>>;

/// @type:
/// FT_Raster
///
/// @description:
/// An opaque handle (pointer) to a raster object.  Each object can be
/// used independently to convert an outline into a bitmap or pixmap.
///
/// @note:
/// In FreeType 2, all rasters are now encapsulated within specific
/// @FT_Renderer modules and only used in their context.
typedef FT_Raster = ffi.Pointer<FT_RasterRec_>;

/// @functype:
/// FT_Raster_ResetFunc
///
/// @description:
/// FreeType used to provide an area of memory called the 'render pool'
/// available to all registered rasterizers.  This was not thread safe,
/// however, and now FreeType never allocates this pool.
///
/// This function is called after a new raster object is created.
///
/// @input:
/// raster ::
/// A handle to the new raster object.
///
/// pool_base ::
/// Previously, the address in memory of the render pool.  Set this to
/// `NULL`.
///
/// pool_size ::
/// Previously, the size in bytes of the render pool.  Set this to 0.
///
/// @note:
/// Rasterizers should rely on dynamic or stack allocation if they want to
/// (a handle to the memory allocator is passed to the rasterizer
/// constructor).
typedef FT_Raster_ResetFunc = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(
            FT_Raster, ffi.Pointer<ffi.UnsignedChar>, ffi.UnsignedLong)>>;

/// @functype:
/// FT_Raster_SetModeFunc
///
/// @description:
/// This function is a generic facility to change modes or attributes in a
/// given raster.  This can be used for debugging purposes, or simply to
/// allow implementation-specific 'features' in a given raster module.
///
/// @input:
/// raster ::
/// A handle to the new raster object.
///
/// mode ::
/// A 4-byte tag used to name the mode or property.
///
/// args ::
/// A pointer to the new mode/property to use.
typedef FT_Raster_SetModeFunc = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(FT_Raster, ffi.UnsignedLong, ffi.Pointer<ffi.Void>)>>;

/// @functype:
/// FT_Raster_RenderFunc
///
/// @description:
/// Invoke a given raster to scan-convert a given glyph image into a
/// target bitmap.
///
/// @input:
/// raster ::
/// A handle to the raster object.
///
/// params ::
/// A pointer to an @FT_Raster_Params structure used to store the
/// rendering parameters.
///
/// @return:
/// Error code.  0~means success.
///
/// @note:
/// The exact format of the source image depends on the raster's glyph
/// format defined in its @FT_Raster_Funcs structure.  It can be an
/// @FT_Outline or anything else in order to support a large array of
/// glyph formats.
///
/// Note also that the render function can fail and return a
/// `FT_Err_Unimplemented_Feature` error code if the raster used does not
/// support direct composition.
typedef FT_Raster_RenderFunc = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(FT_Raster, ffi.Pointer<FT_Raster_Params>)>>;

/// @struct:
/// FT_Raster_Params
///
/// @description:
/// A structure to hold the parameters used by a raster's render function,
/// passed as an argument to @FT_Outline_Render.
///
/// @fields:
/// target ::
/// The target bitmap.
///
/// source ::
/// A pointer to the source glyph image (e.g., an @FT_Outline).
///
/// flags ::
/// The rendering flags.
///
/// gray_spans ::
/// The gray span drawing callback.
///
/// black_spans ::
/// Unused.
///
/// bit_test ::
/// Unused.
///
/// bit_set ::
/// Unused.
///
/// user ::
/// User-supplied data that is passed to each drawing callback.
///
/// clip_box ::
/// An optional span clipping box expressed in _integer_ pixels
/// (not in 26.6 fixed-point units).
///
/// @note:
/// The @FT_RASTER_FLAG_AA bit flag must be set in the `flags` to
/// generate an anti-aliased glyph bitmap, otherwise a monochrome bitmap
/// is generated.  The `target` should have appropriate pixel mode and its
/// dimensions define the clipping region.
///
/// If both @FT_RASTER_FLAG_AA and @FT_RASTER_FLAG_DIRECT bit flags
/// are set in `flags`, the raster calls an @FT_SpanFunc callback
/// `gray_spans` with `user` data as an argument ignoring `target`.  This
/// allows direct composition over a pre-existing user surface to perform
/// the span drawing and composition.  To optionally clip the spans, set
/// the @FT_RASTER_FLAG_CLIP flag and `clip_box`.  The monochrome raster
/// does not support the direct mode.
///
/// The gray-level rasterizer always uses 256 gray levels.  If you want
/// fewer gray levels, you have to use @FT_RASTER_FLAG_DIRECT and reduce
/// the levels in the callback function.
typedef FT_Raster_Params = FT_Raster_Params_;

/// @functype:
/// FT_Raster_DoneFunc
///
/// @description:
/// A function used to destroy a given raster object.
///
/// @input:
/// raster ::
/// A handle to the raster object.
typedef FT_Raster_DoneFunc
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function(FT_Raster)>>;

/// @struct:
/// FT_UnitVector
///
/// @description:
/// A simple structure used to store a 2D vector unit vector.  Uses
/// FT_F2Dot14 types.
///
/// @fields:
/// x ::
/// Horizontal coordinate.
///
/// y ::
/// Vertical coordinate.
class FT_UnitVector_ extends ffi.Struct {
  @FT_F2Dot14()
  external int x;

  @FT_F2Dot14()
  external int y;
}

/// @type:
/// FT_F2Dot14
///
/// @description:
/// A signed 2.14 fixed-point type used for unit vectors.
typedef FT_F2Dot14 = ffi.Short;

/// @struct:
/// FT_Matrix
///
/// @description:
/// A simple structure used to store a 2x2 matrix.  Coefficients are in
/// 16.16 fixed-point format.  The computation performed is:
///
/// ```
/// x' = x*xx + y*xy
/// y' = x*yx + y*yy
/// ```
///
/// @fields:
/// xx ::
/// Matrix coefficient.
///
/// xy ::
/// Matrix coefficient.
///
/// yx ::
/// Matrix coefficient.
///
/// yy ::
/// Matrix coefficient.
class FT_Matrix_ extends ffi.Struct {
  @FT_Fixed()
  external int xx;

  @FT_Fixed()
  external int xy;

  @FT_Fixed()
  external int yx;

  @FT_Fixed()
  external int yy;
}

/// @type:
/// FT_Fixed
///
/// @description:
/// This type is used to store 16.16 fixed-point values, like scaling
/// values or matrix coefficients.
typedef FT_Fixed = ffi.Long;

/// @struct:
/// FT_Data
///
/// @description:
/// Read-only binary data represented as a pointer and a length.
///
/// @fields:
/// pointer ::
/// The data.
///
/// length ::
/// The length of the data in bytes.
class FT_Data_ extends ffi.Struct {
  external ffi.Pointer<FT_Byte> pointer;

  @FT_UInt()
  external int length;
}

/// @type:
/// FT_Byte
///
/// @description:
/// A simple typedef for the _unsigned_ char type.
typedef FT_Byte = ffi.UnsignedChar;

/// @type:
/// FT_UInt
///
/// @description:
/// A typedef for the unsigned int type.
typedef FT_UInt = ffi.UnsignedInt;

/// @struct:
/// FT_Generic
///
/// @description:
/// Client applications often need to associate their own data to a
/// variety of FreeType core objects.  For example, a text layout API
/// might want to associate a glyph cache to a given size object.
///
/// Some FreeType object contains a `generic` field, of type `FT_Generic`,
/// which usage is left to client applications and font servers.
///
/// It can be used to store a pointer to client-specific data, as well as
/// the address of a 'finalizer' function, which will be called by
/// FreeType when the object is destroyed (for example, the previous
/// client example would put the address of the glyph cache destructor in
/// the `finalizer` field).
///
/// @fields:
/// data ::
/// A typeless pointer to any client-specified data. This field is
/// completely ignored by the FreeType library.
///
/// finalizer ::
/// A pointer to a 'generic finalizer' function, which will be called
/// when the object is destroyed.  If this field is set to `NULL`, no
/// code will be called.
class FT_Generic_ extends ffi.Struct {
  external ffi.Pointer<ffi.Void> data;

  external FT_Generic_Finalizer finalizer;
}

/// @functype:
/// FT_Generic_Finalizer
///
/// @description:
/// Describe a function used to destroy the 'client' data of any FreeType
/// object.  See the description of the @FT_Generic type for details of
/// usage.
///
/// @input:
/// The address of the FreeType object that is under finalization.  Its
/// client data is accessed through its `generic` field.
typedef FT_Generic_Finalizer
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>;

/// @struct:
/// FT_ListNodeRec
///
/// @description:
/// A structure used to hold a single list element.
///
/// @fields:
/// prev ::
/// The previous element in the list.  `NULL` if first.
///
/// next ::
/// The next element in the list.  `NULL` if last.
///
/// data ::
/// A typeless pointer to the listed object.
class FT_ListNodeRec_ extends ffi.Struct {
  external FT_ListNode prev;

  external FT_ListNode next;

  external ffi.Pointer<ffi.Void> data;
}

/// @type:
/// FT_ListNode
///
/// @description:
/// Many elements and objects in FreeType are listed through an @FT_List
/// record (see @FT_ListRec).  As its name suggests, an FT_ListNode is a
/// handle to a single list element.
typedef FT_ListNode = ffi.Pointer<FT_ListNodeRec_>;

/// @struct:
/// FT_ListRec
///
/// @description:
/// A structure used to hold a simple doubly-linked list.  These are used
/// in many parts of FreeType.
///
/// @fields:
/// head ::
/// The head (first element) of doubly-linked list.
///
/// tail ::
/// The tail (last element) of doubly-linked list.
class FT_ListRec_ extends ffi.Struct {
  external FT_ListNode head;

  external FT_ListNode tail;
}

/// @type:
/// FT_Error
///
/// @description:
/// The FreeType error code type.  A value of~0 is always interpreted as a
/// successful operation.
typedef FT_Error = ffi.Int;

/// @struct:
/// FT_Glyph_Metrics
///
/// @description:
/// A structure to model the metrics of a single glyph.  The values are
/// expressed in 26.6 fractional pixel format; if the flag
/// @FT_LOAD_NO_SCALE has been used while loading the glyph, values are
/// expressed in font units instead.
///
/// @fields:
/// width ::
/// The glyph's width.
///
/// height ::
/// The glyph's height.
///
/// horiBearingX ::
/// Left side bearing for horizontal layout.
///
/// horiBearingY ::
/// Top side bearing for horizontal layout.
///
/// horiAdvance ::
/// Advance width for horizontal layout.
///
/// vertBearingX ::
/// Left side bearing for vertical layout.
///
/// vertBearingY ::
/// Top side bearing for vertical layout.  Larger positive values mean
/// further below the vertical glyph origin.
///
/// vertAdvance ::
/// Advance height for vertical layout.  Positive values mean the glyph
/// has a positive advance downward.
///
/// @note:
/// If not disabled with @FT_LOAD_NO_HINTING, the values represent
/// dimensions of the hinted glyph (in case hinting is applicable).
///
/// Stroking a glyph with an outside border does not increase
/// `horiAdvance` or `vertAdvance`; you have to manually adjust these
/// values to account for the added width and height.
///
/// FreeType doesn't use the 'VORG' table data for CFF fonts because it
/// doesn't have an interface to quickly retrieve the glyph height.  The
/// y~coordinate of the vertical origin can be simply computed as
/// `vertBearingY + height` after loading a glyph.
class FT_Glyph_Metrics_ extends ffi.Struct {
  @FT_Pos()
  external int width;

  @FT_Pos()
  external int height;

  @FT_Pos()
  external int horiBearingX;

  @FT_Pos()
  external int horiBearingY;

  @FT_Pos()
  external int horiAdvance;

  @FT_Pos()
  external int vertBearingX;

  @FT_Pos()
  external int vertBearingY;

  @FT_Pos()
  external int vertAdvance;
}

/// @struct:
/// FT_Bitmap_Size
///
/// @description:
/// This structure models the metrics of a bitmap strike (i.e., a set of
/// glyphs for a given point size and resolution) in a bitmap font.  It is
/// used for the `available_sizes` field of @FT_Face.
///
/// @fields:
/// height ::
/// The vertical distance, in pixels, between two consecutive baselines.
/// It is always positive.
///
/// width ::
/// The average width, in pixels, of all glyphs in the strike.
///
/// size ::
/// The nominal size of the strike in 26.6 fractional points.  This
/// field is not very useful.
///
/// x_ppem ::
/// The horizontal ppem (nominal width) in 26.6 fractional pixels.
///
/// y_ppem ::
/// The vertical ppem (nominal height) in 26.6 fractional pixels.
///
/// @note:
/// Windows FNT:
/// The nominal size given in a FNT font is not reliable.  If the driver
/// finds it incorrect, it sets `size` to some calculated values, and
/// `x_ppem` and `y_ppem` to the pixel width and height given in the
/// font, respectively.
///
/// TrueType embedded bitmaps:
/// `size`, `width`, and `height` values are not contained in the bitmap
/// strike itself.  They are computed from the global font parameters.
class FT_Bitmap_Size_ extends ffi.Struct {
  @FT_Short()
  external int height;

  @FT_Short()
  external int width;

  @FT_Pos()
  external int size;

  @FT_Pos()
  external int x_ppem;

  @FT_Pos()
  external int y_ppem;
}

/// @type:
/// FT_Short
///
/// @description:
/// A typedef for signed short.
typedef FT_Short = ffi.Short;

class FT_LibraryRec_ extends ffi.Opaque {}

class FT_ModuleRec_ extends ffi.Opaque {}

class FT_DriverRec_ extends ffi.Opaque {}

class FT_RendererRec_ extends ffi.Opaque {}

/// @struct:
/// FT_FaceRec
///
/// @description:
/// FreeType root face class structure.  A face object models a typeface
/// in a font file.
///
/// @fields:
/// num_faces ::
/// The number of faces in the font file.  Some font formats can have
/// multiple faces in a single font file.
///
/// face_index ::
/// This field holds two different values.  Bits 0-15 are the index of
/// the face in the font file (starting with value~0).  They are set
/// to~0 if there is only one face in the font file.
///
/// [Since 2.6.1] Bits 16-30 are relevant to GX and OpenType variation
/// fonts only, holding the named instance index for the current face
/// index (starting with value~1; value~0 indicates font access without
/// a named instance).  For non-variation fonts, bits 16-30 are ignored.
/// If we have the third named instance of face~4, say, `face_index` is
/// set to 0x00030004.
///
/// Bit 31 is always zero (this is, `face_index` is always a positive
/// value).
///
/// [Since 2.9] Changing the design coordinates with
/// @FT_Set_Var_Design_Coordinates or @FT_Set_Var_Blend_Coordinates does
/// not influence the named instance index value (only
/// @FT_Set_Named_Instance does that).
///
/// face_flags ::
/// A set of bit flags that give important information about the face;
/// see @FT_FACE_FLAG_XXX for the details.
///
/// style_flags ::
/// The lower 16~bits contain a set of bit flags indicating the style of
/// the face; see @FT_STYLE_FLAG_XXX for the details.
///
/// [Since 2.6.1] Bits 16-30 hold the number of named instances
/// available for the current face if we have a GX or OpenType variation
/// (sub)font.  Bit 31 is always zero (this is, `style_flags` is always
/// a positive value).  Note that a variation font has always at least
/// one named instance, namely the default instance.
///
/// num_glyphs ::
/// The number of glyphs in the face.  If the face is scalable and has
/// sbits (see `num_fixed_sizes`), it is set to the number of outline
/// glyphs.
///
/// For CID-keyed fonts (not in an SFNT wrapper) this value gives the
/// highest CID used in the font.
///
/// family_name ::
/// The face's family name.  This is an ASCII string, usually in
/// English, that describes the typeface's family (like 'Times New
/// Roman', 'Bodoni', 'Garamond', etc).  This is a least common
/// denominator used to list fonts.  Some formats (TrueType & OpenType)
/// provide localized and Unicode versions of this string.  Applications
/// should use the format-specific interface to access them.  Can be
/// `NULL` (e.g., in fonts embedded in a PDF file).
///
/// In case the font doesn't provide a specific family name entry,
/// FreeType tries to synthesize one, deriving it from other name
/// entries.
///
/// style_name ::
/// The face's style name.  This is an ASCII string, usually in English,
/// that describes the typeface's style (like 'Italic', 'Bold',
/// 'Condensed', etc).  Not all font formats provide a style name, so
/// this field is optional, and can be set to `NULL`.  As for
/// `family_name`, some formats provide localized and Unicode versions
/// of this string.  Applications should use the format-specific
/// interface to access them.
///
/// num_fixed_sizes ::
/// The number of bitmap strikes in the face.  Even if the face is
/// scalable, there might still be bitmap strikes, which are called
/// 'sbits' in that case.
///
/// available_sizes ::
/// An array of @FT_Bitmap_Size for all bitmap strikes in the face.  It
/// is set to `NULL` if there is no bitmap strike.
///
/// Note that FreeType tries to sanitize the strike data since they are
/// sometimes sloppy or incorrect, but this can easily fail.
///
/// num_charmaps ::
/// The number of charmaps in the face.
///
/// charmaps ::
/// An array of the charmaps of the face.
///
/// generic ::
/// A field reserved for client uses.  See the @FT_Generic type
/// description.
///
/// bbox ::
/// The font bounding box.  Coordinates are expressed in font units (see
/// `units_per_EM`).  The box is large enough to contain any glyph from
/// the font.  Thus, `bbox.yMax` can be seen as the 'maximum ascender',
/// and `bbox.yMin` as the 'minimum descender'.  Only relevant for
/// scalable formats.
///
/// Note that the bounding box might be off by (at least) one pixel for
/// hinted fonts.  See @FT_Size_Metrics for further discussion.
///
/// Note that the bounding box does not vary in OpenType variable fonts
/// and should only be used in relation to the default instance.
///
/// units_per_EM ::
/// The number of font units per EM square for this face.  This is
/// typically 2048 for TrueType fonts, and 1000 for Type~1 fonts.  Only
/// relevant for scalable formats.
///
/// ascender ::
/// The typographic ascender of the face, expressed in font units.  For
/// font formats not having this information, it is set to `bbox.yMax`.
/// Only relevant for scalable formats.
///
/// descender ::
/// The typographic descender of the face, expressed in font units.  For
/// font formats not having this information, it is set to `bbox.yMin`.
/// Note that this field is negative for values below the baseline.
/// Only relevant for scalable formats.
///
/// height ::
/// This value is the vertical distance between two consecutive
/// baselines, expressed in font units.  It is always positive.  Only
/// relevant for scalable formats.
///
/// If you want the global glyph height, use `ascender - descender`.
///
/// max_advance_width ::
/// The maximum advance width, in font units, for all glyphs in this
/// face.  This can be used to make word wrapping computations faster.
/// Only relevant for scalable formats.
///
/// max_advance_height ::
/// The maximum advance height, in font units, for all glyphs in this
/// face.  This is only relevant for vertical layouts, and is set to
/// `height` for fonts that do not provide vertical metrics.  Only
/// relevant for scalable formats.
///
/// underline_position ::
/// The position, in font units, of the underline line for this face.
/// It is the center of the underlining stem.  Only relevant for
/// scalable formats.
///
/// underline_thickness ::
/// The thickness, in font units, of the underline for this face.  Only
/// relevant for scalable formats.
///
/// glyph ::
/// The face's associated glyph slot(s).
///
/// size ::
/// The current active size for this face.
///
/// charmap ::
/// The current active charmap for this face.
///
/// @note:
/// Fields may be changed after a call to @FT_Attach_File or
/// @FT_Attach_Stream.
///
/// For an OpenType variation font, the values of the following fields can
/// change after a call to @FT_Set_Var_Design_Coordinates (and friends) if
/// the font contains an 'MVAR' table: `ascender`, `descender`, `height`,
/// `underline_position`, and `underline_thickness`.
///
/// Especially for TrueType fonts see also the documentation for
/// @FT_Size_Metrics.
class FT_FaceRec_ extends ffi.Struct {
  @FT_Long()
  external int num_faces;

  @FT_Long()
  external int face_index;

  @FT_Long()
  external int face_flags;

  @FT_Long()
  external int style_flags;

  @FT_Long()
  external int num_glyphs;

  external ffi.Pointer<FT_String> family_name;

  external ffi.Pointer<FT_String> style_name;

  @FT_Int()
  external int num_fixed_sizes;

  external ffi.Pointer<FT_Bitmap_Size> available_sizes;

  @FT_Int()
  external int num_charmaps;

  external ffi.Pointer<FT_CharMap> charmaps;

  external FT_Generic generic;

  external FT_BBox bbox;

  @FT_UShort()
  external int units_per_EM;

  @FT_Short()
  external int ascender;

  @FT_Short()
  external int descender;

  @FT_Short()
  external int height;

  @FT_Short()
  external int max_advance_width;

  @FT_Short()
  external int max_advance_height;

  @FT_Short()
  external int underline_position;

  @FT_Short()
  external int underline_thickness;

  external FT_GlyphSlot glyph;

  external FT_Size size;

  external FT_CharMap charmap;

  external FT_Driver driver;

  external FT_Memory memory;

  external FT_Stream stream;

  external FT_ListRec sizes_list;

  external FT_Generic autohint;

  external ffi.Pointer<ffi.Void> extensions;

  external FT_Face_Internal internal;
}

/// @type:
/// FT_Long
///
/// @description:
/// A typedef for signed long.
typedef FT_Long = ffi.Long;

/// @type:
/// FT_String
///
/// @description:
/// A simple typedef for the char type, usually used for strings.
typedef FT_String = ffi.Char;

/// @type:
/// FT_Int
///
/// @description:
/// A typedef for the int type.
typedef FT_Int = ffi.Int;

/// @struct:
/// FT_Bitmap_Size
///
/// @description:
/// This structure models the metrics of a bitmap strike (i.e., a set of
/// glyphs for a given point size and resolution) in a bitmap font.  It is
/// used for the `available_sizes` field of @FT_Face.
///
/// @fields:
/// height ::
/// The vertical distance, in pixels, between two consecutive baselines.
/// It is always positive.
///
/// width ::
/// The average width, in pixels, of all glyphs in the strike.
///
/// size ::
/// The nominal size of the strike in 26.6 fractional points.  This
/// field is not very useful.
///
/// x_ppem ::
/// The horizontal ppem (nominal width) in 26.6 fractional pixels.
///
/// y_ppem ::
/// The vertical ppem (nominal height) in 26.6 fractional pixels.
///
/// @note:
/// Windows FNT:
/// The nominal size given in a FNT font is not reliable.  If the driver
/// finds it incorrect, it sets `size` to some calculated values, and
/// `x_ppem` and `y_ppem` to the pixel width and height given in the
/// font, respectively.
///
/// TrueType embedded bitmaps:
/// `size`, `width`, and `height` values are not contained in the bitmap
/// strike itself.  They are computed from the global font parameters.
typedef FT_Bitmap_Size = FT_Bitmap_Size_;

/// @type:
/// FT_CharMap
///
/// @description:
/// A handle to a character map (usually abbreviated to 'charmap').  A
/// charmap is used to translate character codes in a given encoding into
/// glyph indexes for its parent's face.  Some font formats may provide
/// several charmaps per font.
///
/// Each face object owns zero or more charmaps, but only one of them can
/// be 'active', providing the data used by @FT_Get_Char_Index or
/// @FT_Load_Char.
///
/// The list of available charmaps in a face is available through the
/// `face->num_charmaps` and `face->charmaps` fields of @FT_FaceRec.
///
/// The currently active charmap is available as `face->charmap`.  You
/// should call @FT_Set_Charmap to change it.
///
/// @note:
/// When a new face is created (either through @FT_New_Face or
/// @FT_Open_Face), the library looks for a Unicode charmap within the
/// list and automatically activates it.  If there is no Unicode charmap,
/// FreeType doesn't set an 'active' charmap.
///
/// @also:
/// See @FT_CharMapRec for the publicly accessible fields of a given
/// character map.
typedef FT_CharMap = ffi.Pointer<FT_CharMapRec_>;

/// @struct:
/// FT_CharMapRec
///
/// @description:
/// The base charmap structure.
///
/// @fields:
/// face ::
/// A handle to the parent face object.
///
/// encoding ::
/// An @FT_Encoding tag identifying the charmap.  Use this with
/// @FT_Select_Charmap.
///
/// platform_id ::
/// An ID number describing the platform for the following encoding ID.
/// This comes directly from the TrueType specification and gets
/// emulated for other formats.
///
/// encoding_id ::
/// A platform-specific encoding number.  This also comes from the
/// TrueType specification and gets emulated similarly.
class FT_CharMapRec_ extends ffi.Struct {
  external FT_Face face;

  @ffi.Int32()
  external int encoding;

  @FT_UShort()
  external int platform_id;

  @FT_UShort()
  external int encoding_id;
}

/// @type:
/// FT_Face
///
/// @description:
/// A handle to a typographic face object.  A face object models a given
/// typeface, in a given style.
///
/// @note:
/// A face object also owns a single @FT_GlyphSlot object, as well as one
/// or more @FT_Size objects.
///
/// Use @FT_New_Face or @FT_Open_Face to create a new face object from a
/// given filepath or a custom input stream.
///
/// Use @FT_Done_Face to destroy it (along with its slot and sizes).
///
/// An `FT_Face` object can only be safely used from one thread at a time.
/// Similarly, creation and destruction of `FT_Face` with the same
/// @FT_Library object can only be done from one thread at a time.  On the
/// other hand, functions like @FT_Load_Glyph and its siblings are
/// thread-safe and do not need the lock to be held as long as the same
/// `FT_Face` object is not used from multiple threads at the same time.
///
/// @also:
/// See @FT_FaceRec for the publicly accessible fields of a given face
/// object.
typedef FT_Face = ffi.Pointer<FT_FaceRec_>;

/// @enum:
/// FT_Encoding
///
/// @description:
/// An enumeration to specify character sets supported by charmaps.  Used
/// in the @FT_Select_Charmap API function.
///
/// @note:
/// Despite the name, this enumeration lists specific character
/// repertoires (i.e., charsets), and not text encoding methods (e.g.,
/// UTF-8, UTF-16, etc.).
///
/// Other encodings might be defined in the future.
///
/// @values:
/// FT_ENCODING_NONE ::
/// The encoding value~0 is reserved for all formats except BDF, PCF,
/// and Windows FNT; see below for more information.
///
/// FT_ENCODING_UNICODE ::
/// The Unicode character set.  This value covers all versions of the
/// Unicode repertoire, including ASCII and Latin-1.  Most fonts include
/// a Unicode charmap, but not all of them.
///
/// For example, if you want to access Unicode value U+1F028 (and the
/// font contains it), use value 0x1F028 as the input value for
/// @FT_Get_Char_Index.
///
/// FT_ENCODING_MS_SYMBOL ::
/// Microsoft Symbol encoding, used to encode mathematical symbols and
/// wingdings.  For more information, see
/// 'https://www.microsoft.com/typography/otspec/recom.htm#non-standard-symbol-fonts',
/// 'http://www.kostis.net/charsets/symbol.htm', and
/// 'http://www.kostis.net/charsets/wingding.htm'.
///
/// This encoding uses character codes from the PUA (Private Unicode
/// Area) in the range U+F020-U+F0FF.
///
/// FT_ENCODING_SJIS ::
/// Shift JIS encoding for Japanese.  More info at
/// 'https://en.wikipedia.org/wiki/Shift_JIS'.  See note on multi-byte
/// encodings below.
///
/// FT_ENCODING_PRC ::
/// Corresponds to encoding systems mainly for Simplified Chinese as
/// used in People's Republic of China (PRC).  The encoding layout is
/// based on GB~2312 and its supersets GBK and GB~18030.
///
/// FT_ENCODING_BIG5 ::
/// Corresponds to an encoding system for Traditional Chinese as used in
/// Taiwan and Hong Kong.
///
/// FT_ENCODING_WANSUNG ::
/// Corresponds to the Korean encoding system known as Extended Wansung
/// (MS Windows code page 949).  For more information see
/// 'https://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WindowsBestFit/bestfit949.txt'.
///
/// FT_ENCODING_JOHAB ::
/// The Korean standard character set (KS~C 5601-1992), which
/// corresponds to MS Windows code page 1361.  This character set
/// includes all possible Hangul character combinations.
///
/// FT_ENCODING_ADOBE_LATIN_1 ::
/// Corresponds to a Latin-1 encoding as defined in a Type~1 PostScript
/// font.  It is limited to 256 character codes.
///
/// FT_ENCODING_ADOBE_STANDARD ::
/// Adobe Standard encoding, as found in Type~1, CFF, and OpenType/CFF
/// fonts.  It is limited to 256 character codes.
///
/// FT_ENCODING_ADOBE_EXPERT ::
/// Adobe Expert encoding, as found in Type~1, CFF, and OpenType/CFF
/// fonts.  It is limited to 256 character codes.
///
/// FT_ENCODING_ADOBE_CUSTOM ::
/// Corresponds to a custom encoding, as found in Type~1, CFF, and
/// OpenType/CFF fonts.  It is limited to 256 character codes.
///
/// FT_ENCODING_APPLE_ROMAN ::
/// Apple roman encoding.  Many TrueType and OpenType fonts contain a
/// charmap for this 8-bit encoding, since older versions of Mac OS are
/// able to use it.
///
/// FT_ENCODING_OLD_LATIN_2 ::
/// This value is deprecated and was neither used nor reported by
/// FreeType.  Don't use or test for it.
///
/// FT_ENCODING_MS_SJIS ::
/// Same as FT_ENCODING_SJIS.  Deprecated.
///
/// FT_ENCODING_MS_GB2312 ::
/// Same as FT_ENCODING_PRC.  Deprecated.
///
/// FT_ENCODING_MS_BIG5 ::
/// Same as FT_ENCODING_BIG5.  Deprecated.
///
/// FT_ENCODING_MS_WANSUNG ::
/// Same as FT_ENCODING_WANSUNG.  Deprecated.
///
/// FT_ENCODING_MS_JOHAB ::
/// Same as FT_ENCODING_JOHAB.  Deprecated.
///
/// @note:
/// When loading a font, FreeType makes a Unicode charmap active if
/// possible (either if the font provides such a charmap, or if FreeType
/// can synthesize one from PostScript glyph name dictionaries; in either
/// case, the charmap is tagged with `FT_ENCODING_UNICODE`).  If such a
/// charmap is synthesized, it is placed at the first position of the
/// charmap array.
///
/// All other encodings are considered legacy and tagged only if
/// explicitly defined in the font file.  Otherwise, `FT_ENCODING_NONE` is
/// used.
///
/// `FT_ENCODING_NONE` is set by the BDF and PCF drivers if the charmap is
/// neither Unicode nor ISO-8859-1 (otherwise it is set to
/// `FT_ENCODING_UNICODE`).  Use @FT_Get_BDF_Charset_ID to find out which
/// encoding is really present.  If, for example, the `cs_registry` field
/// is 'KOI8' and the `cs_encoding` field is 'R', the font is encoded in
/// KOI8-R.
///
/// `FT_ENCODING_NONE` is always set (with a single exception) by the
/// winfonts driver.  Use @FT_Get_WinFNT_Header and examine the `charset`
/// field of the @FT_WinFNT_HeaderRec structure to find out which encoding
/// is really present.  For example, @FT_WinFNT_ID_CP1251 (204) means
/// Windows code page 1251 (for Russian).
///
/// `FT_ENCODING_NONE` is set if `platform_id` is @TT_PLATFORM_MACINTOSH
/// and `encoding_id` is not `TT_MAC_ID_ROMAN` (otherwise it is set to
/// `FT_ENCODING_APPLE_ROMAN`).
///
/// If `platform_id` is @TT_PLATFORM_MACINTOSH, use the function
/// @FT_Get_CMap_Language_ID to query the Mac language ID that may be
/// needed to be able to distinguish Apple encoding variants.  See
///
/// https://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt
///
/// to get an idea how to do that.  Basically, if the language ID is~0,
/// don't use it, otherwise subtract 1 from the language ID.  Then examine
/// `encoding_id`.  If, for example, `encoding_id` is `TT_MAC_ID_ROMAN`
/// and the language ID (minus~1) is `TT_MAC_LANGID_GREEK`, it is the
/// Greek encoding, not Roman.  `TT_MAC_ID_ARABIC` with
/// `TT_MAC_LANGID_FARSI` means the Farsi variant of the Arabic encoding.
abstract class FT_Encoding_ {
  static const int FT_ENCODING_NONE = 0;
  static const int FT_ENCODING_MS_SYMBOL = 1937337698;
  static const int FT_ENCODING_UNICODE = 1970170211;
  static const int FT_ENCODING_SJIS = 1936353651;
  static const int FT_ENCODING_PRC = 1734484000;
  static const int FT_ENCODING_BIG5 = 1651074869;
  static const int FT_ENCODING_WANSUNG = 2002873971;
  static const int FT_ENCODING_JOHAB = 1785686113;
  static const int FT_ENCODING_GB2312 = 1734484000;
  static const int FT_ENCODING_MS_SJIS = 1936353651;
  static const int FT_ENCODING_MS_GB2312 = 1734484000;
  static const int FT_ENCODING_MS_BIG5 = 1651074869;
  static const int FT_ENCODING_MS_WANSUNG = 2002873971;
  static const int FT_ENCODING_MS_JOHAB = 1785686113;
  static const int FT_ENCODING_ADOBE_STANDARD = 1094995778;
  static const int FT_ENCODING_ADOBE_EXPERT = 1094992453;
  static const int FT_ENCODING_ADOBE_CUSTOM = 1094992451;
  static const int FT_ENCODING_ADOBE_LATIN_1 = 1818326065;
  static const int FT_ENCODING_OLD_LATIN_2 = 1818326066;
  static const int FT_ENCODING_APPLE_ROMAN = 1634889070;
}

/// @type:
/// FT_UShort
///
/// @description:
/// A typedef for unsigned short.
typedef FT_UShort = ffi.UnsignedShort;

/// @struct:
/// FT_Generic
///
/// @description:
/// Client applications often need to associate their own data to a
/// variety of FreeType core objects.  For example, a text layout API
/// might want to associate a glyph cache to a given size object.
///
/// Some FreeType object contains a `generic` field, of type `FT_Generic`,
/// which usage is left to client applications and font servers.
///
/// It can be used to store a pointer to client-specific data, as well as
/// the address of a 'finalizer' function, which will be called by
/// FreeType when the object is destroyed (for example, the previous
/// client example would put the address of the glyph cache destructor in
/// the `finalizer` field).
///
/// @fields:
/// data ::
/// A typeless pointer to any client-specified data. This field is
/// completely ignored by the FreeType library.
///
/// finalizer ::
/// A pointer to a 'generic finalizer' function, which will be called
/// when the object is destroyed.  If this field is set to `NULL`, no
/// code will be called.
typedef FT_Generic = FT_Generic_;

/// @type:
/// FT_GlyphSlot
///
/// @description:
/// A handle to a given 'glyph slot'.  A slot is a container that can hold
/// any of the glyphs contained in its parent face.
///
/// In other words, each time you call @FT_Load_Glyph or @FT_Load_Char,
/// the slot's content is erased by the new glyph data, i.e., the glyph's
/// metrics, its image (bitmap or outline), and other control information.
///
/// @also:
/// See @FT_GlyphSlotRec for the publicly accessible glyph fields.
typedef FT_GlyphSlot = ffi.Pointer<FT_GlyphSlotRec_>;

/// @struct:
/// FT_GlyphSlotRec
///
/// @description:
/// FreeType root glyph slot class structure.  A glyph slot is a container
/// where individual glyphs can be loaded, be they in outline or bitmap
/// format.
///
/// @fields:
/// library ::
/// A handle to the FreeType library instance this slot belongs to.
///
/// face ::
/// A handle to the parent face object.
///
/// next ::
/// In some cases (like some font tools), several glyph slots per face
/// object can be a good thing.  As this is rare, the glyph slots are
/// listed through a direct, single-linked list using its `next` field.
///
/// glyph_index ::
/// [Since 2.10] The glyph index passed as an argument to @FT_Load_Glyph
/// while initializing the glyph slot.
///
/// generic ::
/// A typeless pointer unused by the FreeType library or any of its
/// drivers.  It can be used by client applications to link their own
/// data to each glyph slot object.
///
/// metrics ::
/// The metrics of the last loaded glyph in the slot.  The returned
/// values depend on the last load flags (see the @FT_Load_Glyph API
/// function) and can be expressed either in 26.6 fractional pixels or
/// font units.
///
/// Note that even when the glyph image is transformed, the metrics are
/// not.
///
/// linearHoriAdvance ::
/// The advance width of the unhinted glyph.  Its value is expressed in
/// 16.16 fractional pixels, unless @FT_LOAD_LINEAR_DESIGN is set when
/// loading the glyph.  This field can be important to perform correct
/// WYSIWYG layout.  Only relevant for scalable glyphs.
///
/// linearVertAdvance ::
/// The advance height of the unhinted glyph.  Its value is expressed in
/// 16.16 fractional pixels, unless @FT_LOAD_LINEAR_DESIGN is set when
/// loading the glyph.  This field can be important to perform correct
/// WYSIWYG layout.  Only relevant for scalable glyphs.
///
/// advance ::
/// This shorthand is, depending on @FT_LOAD_IGNORE_TRANSFORM, the
/// transformed (hinted) advance width for the glyph, in 26.6 fractional
/// pixel format.  As specified with @FT_LOAD_VERTICAL_LAYOUT, it uses
/// either the `horiAdvance` or the `vertAdvance` value of `metrics`
/// field.
///
/// format ::
/// This field indicates the format of the image contained in the glyph
/// slot.  Typically @FT_GLYPH_FORMAT_BITMAP, @FT_GLYPH_FORMAT_OUTLINE,
/// or @FT_GLYPH_FORMAT_COMPOSITE, but other values are possible.
///
/// bitmap ::
/// This field is used as a bitmap descriptor.  Note that the address
/// and content of the bitmap buffer can change between calls of
/// @FT_Load_Glyph and a few other functions.
///
/// bitmap_left ::
/// The bitmap's left bearing expressed in integer pixels.
///
/// bitmap_top ::
/// The bitmap's top bearing expressed in integer pixels.  This is the
/// distance from the baseline to the top-most glyph scanline, upwards
/// y~coordinates being **positive**.
///
/// outline ::
/// The outline descriptor for the current glyph image if its format is
/// @FT_GLYPH_FORMAT_OUTLINE.  Once a glyph is loaded, `outline` can be
/// transformed, distorted, emboldened, etc.  However, it must not be
/// freed.
///
/// [Since 2.10.1] If @FT_LOAD_NO_SCALE is set, outline coordinates of
/// OpenType variation fonts for a selected instance are internally
/// handled as 26.6 fractional font units but returned as (rounded)
/// integers, as expected.  To get unrounded font units, don't use
/// @FT_LOAD_NO_SCALE but load the glyph with @FT_LOAD_NO_HINTING and
/// scale it, using the font's `units_per_EM` value as the ppem.
///
/// num_subglyphs ::
/// The number of subglyphs in a composite glyph.  This field is only
/// valid for the composite glyph format that should normally only be
/// loaded with the @FT_LOAD_NO_RECURSE flag.
///
/// subglyphs ::
/// An array of subglyph descriptors for composite glyphs.  There are
/// `num_subglyphs` elements in there.  Currently internal to FreeType.
///
/// control_data ::
/// Certain font drivers can also return the control data for a given
/// glyph image (e.g.  TrueType bytecode, Type~1 charstrings, etc.).
/// This field is a pointer to such data; it is currently internal to
/// FreeType.
///
/// control_len ::
/// This is the length in bytes of the control data.  Currently internal
/// to FreeType.
///
/// other ::
/// Reserved.
///
/// lsb_delta ::
/// The difference between hinted and unhinted left side bearing while
/// auto-hinting is active.  Zero otherwise.
///
/// rsb_delta ::
/// The difference between hinted and unhinted right side bearing while
/// auto-hinting is active.  Zero otherwise.
///
/// @note:
/// If @FT_Load_Glyph is called with default flags (see @FT_LOAD_DEFAULT)
/// the glyph image is loaded in the glyph slot in its native format
/// (e.g., an outline glyph for TrueType and Type~1 formats).  [Since 2.9]
/// The prospective bitmap metrics are calculated according to
/// @FT_LOAD_TARGET_XXX and other flags even for the outline glyph, even
/// if @FT_LOAD_RENDER is not set.
///
/// This image can later be converted into a bitmap by calling
/// @FT_Render_Glyph.  This function searches the current renderer for the
/// native image's format, then invokes it.
///
/// The renderer is in charge of transforming the native image through the
/// slot's face transformation fields, then converting it into a bitmap
/// that is returned in `slot->bitmap`.
///
/// Note that `slot->bitmap_left` and `slot->bitmap_top` are also used to
/// specify the position of the bitmap relative to the current pen
/// position (e.g., coordinates (0,0) on the baseline).  Of course,
/// `slot->format` is also changed to @FT_GLYPH_FORMAT_BITMAP.
///
/// Here is a small pseudo code fragment that shows how to use `lsb_delta`
/// and `rsb_delta` to do fractional positioning of glyphs:
///
/// ```
/// FT_GlyphSlot  slot     = face->glyph;
/// FT_Pos        origin_x = 0;
///
///
/// for all glyphs do
/// <load glyph with `FT_Load_Glyph'>
///
/// FT_Outline_Translate( slot->outline, origin_x & 63, 0 );
///
/// <save glyph image, or render glyph, or ...>
///
/// <compute kern between current and next glyph
/// and add it to `origin_x'>
///
/// origin_x += slot->advance.x;
/// origin_x += slot->lsb_delta - slot->rsb_delta;
/// endfor
/// ```
///
/// Here is another small pseudo code fragment that shows how to use
/// `lsb_delta` and `rsb_delta` to improve integer positioning of glyphs:
///
/// ```
/// FT_GlyphSlot  slot           = face->glyph;
/// FT_Pos        origin_x       = 0;
/// FT_Pos        prev_rsb_delta = 0;
///
///
/// for all glyphs do
/// <compute kern between current and previous glyph
/// and add it to `origin_x'>
///
/// <load glyph with `FT_Load_Glyph'>
///
/// if ( prev_rsb_delta - slot->lsb_delta >  32 )
/// origin_x -= 64;
/// else if ( prev_rsb_delta - slot->lsb_delta < -31 )
/// origin_x += 64;
///
/// prev_rsb_delta = slot->rsb_delta;
///
/// <save glyph image, or render glyph, or ...>
///
/// origin_x += slot->advance.x;
/// endfor
/// ```
///
/// If you use strong auto-hinting, you **must** apply these delta values!
/// Otherwise you will experience far too large inter-glyph spacing at
/// small rendering sizes in most cases.  Note that it doesn't harm to use
/// the above code for other hinting modes also, since the delta values
/// are zero then.
class FT_GlyphSlotRec_ extends ffi.Struct {
  external FT_Library library1;

  external FT_Face face;

  external FT_GlyphSlot1 next;

  @FT_UInt()
  external int glyph_index;

  external FT_Generic generic;

  external FT_Glyph_Metrics metrics;

  @FT_Fixed()
  external int linearHoriAdvance;

  @FT_Fixed()
  external int linearVertAdvance;

  external FT_Vector advance;

  @ffi.Int32()
  external int format;

  external FT_Bitmap bitmap;

  @FT_Int()
  external int bitmap_left;

  @FT_Int()
  external int bitmap_top;

  external FT_Outline outline;

  @FT_UInt()
  external int num_subglyphs;

  external FT_SubGlyph subglyphs;

  external ffi.Pointer<ffi.Void> control_data;

  @ffi.Long()
  external int control_len;

  @FT_Pos()
  external int lsb_delta;

  @FT_Pos()
  external int rsb_delta;

  external ffi.Pointer<ffi.Void> other;

  external FT_Slot_Internal internal;
}

/// @type:
/// FT_Library
///
/// @description:
/// A handle to a FreeType library instance.  Each 'library' is completely
/// independent from the others; it is the 'root' of a set of objects like
/// fonts, faces, sizes, etc.
///
/// It also embeds a memory manager (see @FT_Memory), as well as a
/// scan-line converter object (see @FT_Raster).
///
/// [Since 2.5.6] In multi-threaded applications it is easiest to use one
/// `FT_Library` object per thread.  In case this is too cumbersome, a
/// single `FT_Library` object across threads is possible also, as long as
/// a mutex lock is used around @FT_New_Face and @FT_Done_Face.
///
/// @note:
/// Library objects are normally created by @FT_Init_FreeType, and
/// destroyed with @FT_Done_FreeType.  If you need reference-counting
/// (cf. @FT_Reference_Library), use @FT_New_Library and @FT_Done_Library.
typedef FT_Library = ffi.Pointer<FT_LibraryRec_>;

/// @type:
/// FT_GlyphSlot
///
/// @description:
/// A handle to a given 'glyph slot'.  A slot is a container that can hold
/// any of the glyphs contained in its parent face.
///
/// In other words, each time you call @FT_Load_Glyph or @FT_Load_Char,
/// the slot's content is erased by the new glyph data, i.e., the glyph's
/// metrics, its image (bitmap or outline), and other control information.
///
/// @also:
/// See @FT_GlyphSlotRec for the publicly accessible glyph fields.
typedef FT_GlyphSlot1 = ffi.Pointer<FT_GlyphSlotRec_>;

/// @struct:
/// FT_Glyph_Metrics
///
/// @description:
/// A structure to model the metrics of a single glyph.  The values are
/// expressed in 26.6 fractional pixel format; if the flag
/// @FT_LOAD_NO_SCALE has been used while loading the glyph, values are
/// expressed in font units instead.
///
/// @fields:
/// width ::
/// The glyph's width.
///
/// height ::
/// The glyph's height.
///
/// horiBearingX ::
/// Left side bearing for horizontal layout.
///
/// horiBearingY ::
/// Top side bearing for horizontal layout.
///
/// horiAdvance ::
/// Advance width for horizontal layout.
///
/// vertBearingX ::
/// Left side bearing for vertical layout.
///
/// vertBearingY ::
/// Top side bearing for vertical layout.  Larger positive values mean
/// further below the vertical glyph origin.
///
/// vertAdvance ::
/// Advance height for vertical layout.  Positive values mean the glyph
/// has a positive advance downward.
///
/// @note:
/// If not disabled with @FT_LOAD_NO_HINTING, the values represent
/// dimensions of the hinted glyph (in case hinting is applicable).
///
/// Stroking a glyph with an outside border does not increase
/// `horiAdvance` or `vertAdvance`; you have to manually adjust these
/// values to account for the added width and height.
///
/// FreeType doesn't use the 'VORG' table data for CFF fonts because it
/// doesn't have an interface to quickly retrieve the glyph height.  The
/// y~coordinate of the vertical origin can be simply computed as
/// `vertBearingY + height` after loading a glyph.
typedef FT_Glyph_Metrics = FT_Glyph_Metrics_;

/// @struct:
/// FT_Outline
///
/// @description:
/// This structure is used to describe an outline to the scan-line
/// converter.
///
/// @fields:
/// n_contours ::
/// The number of contours in the outline.
///
/// n_points ::
/// The number of points in the outline.
///
/// points ::
/// A pointer to an array of `n_points` @FT_Vector elements, giving the
/// outline's point coordinates.
///
/// tags ::
/// A pointer to an array of `n_points` chars, giving each outline
/// point's type.
///
/// If bit~0 is unset, the point is 'off' the curve, i.e., a Bezier
/// control point, while it is 'on' if set.
///
/// Bit~1 is meaningful for 'off' points only.  If set, it indicates a
/// third-order Bezier arc control point; and a second-order control
/// point if unset.
///
/// If bit~2 is set, bits 5-7 contain the drop-out mode (as defined in
/// the OpenType specification; the value is the same as the argument to
/// the 'SCANMODE' instruction).
///
/// Bits 3 and~4 are reserved for internal purposes.
///
/// contours ::
/// An array of `n_contours` shorts, giving the end point of each
/// contour within the outline.  For example, the first contour is
/// defined by the points '0' to `contours[0]`, the second one is
/// defined by the points `contours[0]+1` to `contours[1]`, etc.
///
/// flags ::
/// A set of bit flags used to characterize the outline and give hints
/// to the scan-converter and hinter on how to convert/grid-fit it.  See
/// @FT_OUTLINE_XXX.
///
/// @note:
/// The B/W rasterizer only checks bit~2 in the `tags` array for the first
/// point of each contour.  The drop-out mode as given with
/// @FT_OUTLINE_IGNORE_DROPOUTS, @FT_OUTLINE_SMART_DROPOUTS, and
/// @FT_OUTLINE_INCLUDE_STUBS in `flags` is then overridden.
typedef FT_Outline = FT_Outline_;

/// @struct:
/// FT_SubGlyph
///
/// @description:
/// The subglyph structure is an internal object used to describe
/// subglyphs (for example, in the case of composites).
///
/// @note:
/// The subglyph implementation is not part of the high-level API, hence
/// the forward structure declaration.
///
/// You can however retrieve subglyph information with
/// @FT_Get_SubGlyph_Info.
typedef FT_SubGlyph = ffi.Pointer<FT_SubGlyphRec_>;

class FT_SubGlyphRec_ extends ffi.Opaque {}

/// @type:
/// FT_Slot_Internal
///
/// @description:
/// An opaque handle to an `FT_Slot_InternalRec` structure, used to model
/// private data of a given @FT_GlyphSlot object.
typedef FT_Slot_Internal = ffi.Pointer<FT_Slot_InternalRec_>;

class FT_Slot_InternalRec_ extends ffi.Opaque {}

/// @type:
/// FT_Size
///
/// @description:
/// A handle to an object that models a face scaled to a given character
/// size.
///
/// @note:
/// An @FT_Face has one _active_ `FT_Size` object that is used by
/// functions like @FT_Load_Glyph to determine the scaling transformation
/// that in turn is used to load and hint glyphs and metrics.
///
/// A newly created `FT_Size` object contains only meaningless zero values.
/// You must use @FT_Set_Char_Size, @FT_Set_Pixel_Sizes, @FT_Request_Size
/// or even @FT_Select_Size to change the content (i.e., the scaling
/// values) of the active `FT_Size`.  Otherwise, the scaling and hinting
/// will not be performed.
///
/// You can use @FT_New_Size to create additional size objects for a given
/// @FT_Face, but they won't be used by other functions until you activate
/// it through @FT_Activate_Size.  Only one size can be activated at any
/// given time per face.
///
/// @also:
/// See @FT_SizeRec for the publicly accessible fields of a given size
/// object.
typedef FT_Size = ffi.Pointer<FT_SizeRec_>;

/// @struct:
/// FT_SizeRec
///
/// @description:
/// FreeType root size class structure.  A size object models a face
/// object at a given size.
///
/// @fields:
/// face ::
/// Handle to the parent face object.
///
/// generic ::
/// A typeless pointer, unused by the FreeType library or any of its
/// drivers.  It can be used by client applications to link their own
/// data to each size object.
///
/// metrics ::
/// Metrics for this size object.  This field is read-only.
class FT_SizeRec_ extends ffi.Struct {
  external FT_Face face;

  external FT_Generic generic;

  external FT_Size_Metrics metrics;

  external FT_Size_Internal internal;
}

/// @struct:
/// FT_Size_Metrics
///
/// @description:
/// The size metrics structure gives the metrics of a size object.
///
/// @fields:
/// x_ppem ::
/// The width of the scaled EM square in pixels, hence the term 'ppem'
/// (pixels per EM).  It is also referred to as 'nominal width'.
///
/// y_ppem ::
/// The height of the scaled EM square in pixels, hence the term 'ppem'
/// (pixels per EM).  It is also referred to as 'nominal height'.
///
/// x_scale ::
/// A 16.16 fractional scaling value to convert horizontal metrics from
/// font units to 26.6 fractional pixels.  Only relevant for scalable
/// font formats.
///
/// y_scale ::
/// A 16.16 fractional scaling value to convert vertical metrics from
/// font units to 26.6 fractional pixels.  Only relevant for scalable
/// font formats.
///
/// ascender ::
/// The ascender in 26.6 fractional pixels, rounded up to an integer
/// value.  See @FT_FaceRec for the details.
///
/// descender ::
/// The descender in 26.6 fractional pixels, rounded down to an integer
/// value.  See @FT_FaceRec for the details.
///
/// height ::
/// The height in 26.6 fractional pixels, rounded to an integer value.
/// See @FT_FaceRec for the details.
///
/// max_advance ::
/// The maximum advance width in 26.6 fractional pixels, rounded to an
/// integer value.  See @FT_FaceRec for the details.
///
/// @note:
/// The scaling values, if relevant, are determined first during a size
/// changing operation.  The remaining fields are then set by the driver.
/// For scalable formats, they are usually set to scaled values of the
/// corresponding fields in @FT_FaceRec.  Some values like ascender or
/// descender are rounded for historical reasons; more precise values (for
/// outline fonts) can be derived by scaling the corresponding @FT_FaceRec
/// values manually, with code similar to the following.
///
/// ```
/// scaled_ascender = FT_MulFix( face->ascender,
/// size_metrics->y_scale );
/// ```
///
/// Note that due to glyph hinting and the selected rendering mode these
/// values are usually not exact; consequently, they must be treated as
/// unreliable with an error margin of at least one pixel!
///
/// Indeed, the only way to get the exact metrics is to render _all_
/// glyphs.  As this would be a definite performance hit, it is up to
/// client applications to perform such computations.
///
/// The `FT_Size_Metrics` structure is valid for bitmap fonts also.
///
///
/// **TrueType fonts with native bytecode hinting**
///
/// All applications that handle TrueType fonts with native hinting must
/// be aware that TTFs expect different rounding of vertical font
/// dimensions.  The application has to cater for this, especially if it
/// wants to rely on a TTF's vertical data (for example, to properly align
/// box characters vertically).
///
/// Only the application knows _in advance_ that it is going to use native
/// hinting for TTFs!  FreeType, on the other hand, selects the hinting
/// mode not at the time of creating an @FT_Size object but much later,
/// namely while calling @FT_Load_Glyph.
///
/// Here is some pseudo code that illustrates a possible solution.
///
/// ```
/// font_format = FT_Get_Font_Format( face );
///
/// if ( !strcmp( font_format, "TrueType" ) &&
/// do_native_bytecode_hinting         )
/// {
/// ascender  = ROUND( FT_MulFix( face->ascender,
/// size_metrics->y_scale ) );
/// descender = ROUND( FT_MulFix( face->descender,
/// size_metrics->y_scale ) );
/// }
/// else
/// {
/// ascender  = size_metrics->ascender;
/// descender = size_metrics->descender;
/// }
///
/// height      = size_metrics->height;
/// max_advance = size_metrics->max_advance;
/// ```
typedef FT_Size_Metrics = FT_Size_Metrics_;

/// @struct:
/// FT_Size_Metrics
///
/// @description:
/// The size metrics structure gives the metrics of a size object.
///
/// @fields:
/// x_ppem ::
/// The width of the scaled EM square in pixels, hence the term 'ppem'
/// (pixels per EM).  It is also referred to as 'nominal width'.
///
/// y_ppem ::
/// The height of the scaled EM square in pixels, hence the term 'ppem'
/// (pixels per EM).  It is also referred to as 'nominal height'.
///
/// x_scale ::
/// A 16.16 fractional scaling value to convert horizontal metrics from
/// font units to 26.6 fractional pixels.  Only relevant for scalable
/// font formats.
///
/// y_scale ::
/// A 16.16 fractional scaling value to convert vertical metrics from
/// font units to 26.6 fractional pixels.  Only relevant for scalable
/// font formats.
///
/// ascender ::
/// The ascender in 26.6 fractional pixels, rounded up to an integer
/// value.  See @FT_FaceRec for the details.
///
/// descender ::
/// The descender in 26.6 fractional pixels, rounded down to an integer
/// value.  See @FT_FaceRec for the details.
///
/// height ::
/// The height in 26.6 fractional pixels, rounded to an integer value.
/// See @FT_FaceRec for the details.
///
/// max_advance ::
/// The maximum advance width in 26.6 fractional pixels, rounded to an
/// integer value.  See @FT_FaceRec for the details.
///
/// @note:
/// The scaling values, if relevant, are determined first during a size
/// changing operation.  The remaining fields are then set by the driver.
/// For scalable formats, they are usually set to scaled values of the
/// corresponding fields in @FT_FaceRec.  Some values like ascender or
/// descender are rounded for historical reasons; more precise values (for
/// outline fonts) can be derived by scaling the corresponding @FT_FaceRec
/// values manually, with code similar to the following.
///
/// ```
/// scaled_ascender = FT_MulFix( face->ascender,
/// size_metrics->y_scale );
/// ```
///
/// Note that due to glyph hinting and the selected rendering mode these
/// values are usually not exact; consequently, they must be treated as
/// unreliable with an error margin of at least one pixel!
///
/// Indeed, the only way to get the exact metrics is to render _all_
/// glyphs.  As this would be a definite performance hit, it is up to
/// client applications to perform such computations.
///
/// The `FT_Size_Metrics` structure is valid for bitmap fonts also.
///
///
/// **TrueType fonts with native bytecode hinting**
///
/// All applications that handle TrueType fonts with native hinting must
/// be aware that TTFs expect different rounding of vertical font
/// dimensions.  The application has to cater for this, especially if it
/// wants to rely on a TTF's vertical data (for example, to properly align
/// box characters vertically).
///
/// Only the application knows _in advance_ that it is going to use native
/// hinting for TTFs!  FreeType, on the other hand, selects the hinting
/// mode not at the time of creating an @FT_Size object but much later,
/// namely while calling @FT_Load_Glyph.
///
/// Here is some pseudo code that illustrates a possible solution.
///
/// ```
/// font_format = FT_Get_Font_Format( face );
///
/// if ( !strcmp( font_format, "TrueType" ) &&
/// do_native_bytecode_hinting         )
/// {
/// ascender  = ROUND( FT_MulFix( face->ascender,
/// size_metrics->y_scale ) );
/// descender = ROUND( FT_MulFix( face->descender,
/// size_metrics->y_scale ) );
/// }
/// else
/// {
/// ascender  = size_metrics->ascender;
/// descender = size_metrics->descender;
/// }
///
/// height      = size_metrics->height;
/// max_advance = size_metrics->max_advance;
/// ```
class FT_Size_Metrics_ extends ffi.Struct {
  @FT_UShort()
  external int x_ppem;

  @FT_UShort()
  external int y_ppem;

  @FT_Fixed()
  external int x_scale;

  @FT_Fixed()
  external int y_scale;

  @FT_Pos()
  external int ascender;

  @FT_Pos()
  external int descender;

  @FT_Pos()
  external int height;

  @FT_Pos()
  external int max_advance;
}

/// @type:
/// FT_Size_Internal
///
/// @description:
/// An opaque handle to an `FT_Size_InternalRec` structure, used to model
/// private data of a given @FT_Size object.
typedef FT_Size_Internal = ffi.Pointer<FT_Size_InternalRec_>;

class FT_Size_InternalRec_ extends ffi.Opaque {}

/// @type:
/// FT_Driver
///
/// @description:
/// A handle to a given FreeType font driver object.  A font driver is a
/// module capable of creating faces from font files.
typedef FT_Driver = ffi.Pointer<FT_DriverRec_>;

/// @struct:
/// FT_ListRec
///
/// @description:
/// A structure used to hold a simple doubly-linked list.  These are used
/// in many parts of FreeType.
///
/// @fields:
/// head ::
/// The head (first element) of doubly-linked list.
///
/// tail ::
/// The tail (last element) of doubly-linked list.
typedef FT_ListRec = FT_ListRec_;

/// @type:
/// FT_Face_Internal
///
/// @description:
/// An opaque handle to an `FT_Face_InternalRec` structure that models the
/// private data of a given @FT_Face object.
///
/// This structure might change between releases of FreeType~2 and is not
/// generally available to client applications.
typedef FT_Face_Internal = ffi.Pointer<FT_Face_InternalRec_>;

class FT_Face_InternalRec_ extends ffi.Opaque {}

/// @struct:
/// FT_Parameter
///
/// @description:
/// A simple structure to pass more or less generic parameters to
/// @FT_Open_Face and @FT_Face_Properties.
///
/// @fields:
/// tag ::
/// A four-byte identification tag.
///
/// data ::
/// A pointer to the parameter data.
///
/// @note:
/// The ID and function of parameters are driver-specific.  See section
/// @parameter_tags for more information.
class FT_Parameter_ extends ffi.Struct {
  @FT_ULong()
  external int tag;

  external FT_Pointer data;
}

/// @type:
/// FT_ULong
///
/// @description:
/// A typedef for unsigned long.
typedef FT_ULong = ffi.UnsignedLong;

/// @type:
/// FT_Pointer
///
/// @description:
/// A simple typedef for a typeless pointer.
typedef FT_Pointer = ffi.Pointer<ffi.Void>;

/// @struct:
/// FT_Open_Args
///
/// @description:
/// A structure to indicate how to open a new font file or stream.  A
/// pointer to such a structure can be used as a parameter for the
/// functions @FT_Open_Face and @FT_Attach_Stream.
///
/// @fields:
/// flags ::
/// A set of bit flags indicating how to use the structure.
///
/// memory_base ::
/// The first byte of the file in memory.
///
/// memory_size ::
/// The size in bytes of the file in memory.
///
/// pathname ::
/// A pointer to an 8-bit file pathname, which must be a C~string (i.e.,
/// no null bytes except at the very end).  The pointer is not owned by
/// FreeType.
///
/// stream ::
/// A handle to a source stream object.
///
/// driver ::
/// This field is exclusively used by @FT_Open_Face; it simply specifies
/// the font driver to use for opening the face.  If set to `NULL`,
/// FreeType tries to load the face with each one of the drivers in its
/// list.
///
/// num_params ::
/// The number of extra parameters.
///
/// params ::
/// Extra parameters passed to the font driver when opening a new face.
///
/// @note:
/// The stream type is determined by the contents of `flags`:
///
/// If the @FT_OPEN_MEMORY bit is set, assume that this is a memory file
/// of `memory_size` bytes, located at `memory_address`.  The data are not
/// copied, and the client is responsible for releasing and destroying
/// them _after_ the corresponding call to @FT_Done_Face.
///
/// Otherwise, if the @FT_OPEN_STREAM bit is set, assume that a custom
/// input stream `stream` is used.
///
/// Otherwise, if the @FT_OPEN_PATHNAME bit is set, assume that this is a
/// normal file and use `pathname` to open it.
///
/// If none of the above bits are set or if multiple are set at the same
/// time, the flags are invalid and @FT_Open_Face fails.
///
/// If the @FT_OPEN_DRIVER bit is set, @FT_Open_Face only tries to open
/// the file with the driver whose handler is in `driver`.
///
/// If the @FT_OPEN_PARAMS bit is set, the parameters given by
/// `num_params` and `params` is used.  They are ignored otherwise.
///
/// Ideally, both the `pathname` and `params` fields should be tagged as
/// 'const'; this is missing for API backward compatibility.  In other
/// words, applications should treat them as read-only.
class FT_Open_Args_ extends ffi.Struct {
  @FT_UInt()
  external int flags;

  external ffi.Pointer<FT_Byte> memory_base;

  @FT_Long()
  external int memory_size;

  external ffi.Pointer<FT_String> pathname;

  external FT_Stream stream;

  external FT_Module driver;

  @FT_Int()
  external int num_params;

  external ffi.Pointer<FT_Parameter> params;
}

/// @type:
/// FT_Module
///
/// @description:
/// A handle to a given FreeType module object.  A module can be a font
/// driver, a renderer, or anything else that provides services to the
/// former.
typedef FT_Module = ffi.Pointer<FT_ModuleRec_>;

/// @struct:
/// FT_Parameter
///
/// @description:
/// A simple structure to pass more or less generic parameters to
/// @FT_Open_Face and @FT_Face_Properties.
///
/// @fields:
/// tag ::
/// A four-byte identification tag.
///
/// data ::
/// A pointer to the parameter data.
///
/// @note:
/// The ID and function of parameters are driver-specific.  See section
/// @parameter_tags for more information.
typedef FT_Parameter = FT_Parameter_;

/// @struct:
/// FT_Open_Args
///
/// @description:
/// A structure to indicate how to open a new font file or stream.  A
/// pointer to such a structure can be used as a parameter for the
/// functions @FT_Open_Face and @FT_Attach_Stream.
///
/// @fields:
/// flags ::
/// A set of bit flags indicating how to use the structure.
///
/// memory_base ::
/// The first byte of the file in memory.
///
/// memory_size ::
/// The size in bytes of the file in memory.
///
/// pathname ::
/// A pointer to an 8-bit file pathname, which must be a C~string (i.e.,
/// no null bytes except at the very end).  The pointer is not owned by
/// FreeType.
///
/// stream ::
/// A handle to a source stream object.
///
/// driver ::
/// This field is exclusively used by @FT_Open_Face; it simply specifies
/// the font driver to use for opening the face.  If set to `NULL`,
/// FreeType tries to load the face with each one of the drivers in its
/// list.
///
/// num_params ::
/// The number of extra parameters.
///
/// params ::
/// Extra parameters passed to the font driver when opening a new face.
///
/// @note:
/// The stream type is determined by the contents of `flags`:
///
/// If the @FT_OPEN_MEMORY bit is set, assume that this is a memory file
/// of `memory_size` bytes, located at `memory_address`.  The data are not
/// copied, and the client is responsible for releasing and destroying
/// them _after_ the corresponding call to @FT_Done_Face.
///
/// Otherwise, if the @FT_OPEN_STREAM bit is set, assume that a custom
/// input stream `stream` is used.
///
/// Otherwise, if the @FT_OPEN_PATHNAME bit is set, assume that this is a
/// normal file and use `pathname` to open it.
///
/// If none of the above bits are set or if multiple are set at the same
/// time, the flags are invalid and @FT_Open_Face fails.
///
/// If the @FT_OPEN_DRIVER bit is set, @FT_Open_Face only tries to open
/// the file with the driver whose handler is in `driver`.
///
/// If the @FT_OPEN_PARAMS bit is set, the parameters given by
/// `num_params` and `params` is used.  They are ignored otherwise.
///
/// Ideally, both the `pathname` and `params` fields should be tagged as
/// 'const'; this is missing for API backward compatibility.  In other
/// words, applications should treat them as read-only.
typedef FT_Open_Args = FT_Open_Args_;

/// @enum:
/// FT_Size_Request_Type
///
/// @description:
/// An enumeration type that lists the supported size request types, i.e.,
/// what input size (in font units) maps to the requested output size (in
/// pixels, as computed from the arguments of @FT_Size_Request).
///
/// @values:
/// FT_SIZE_REQUEST_TYPE_NOMINAL ::
/// The nominal size.  The `units_per_EM` field of @FT_FaceRec is used
/// to determine both scaling values.
///
/// This is the standard scaling found in most applications.  In
/// particular, use this size request type for TrueType fonts if they
/// provide optical scaling or something similar.  Note, however, that
/// `units_per_EM` is a rather abstract value which bears no relation to
/// the actual size of the glyphs in a font.
///
/// FT_SIZE_REQUEST_TYPE_REAL_DIM ::
/// The real dimension.  The sum of the `ascender` and (minus of) the
/// `descender` fields of @FT_FaceRec is used to determine both scaling
/// values.
///
/// FT_SIZE_REQUEST_TYPE_BBOX ::
/// The font bounding box.  The width and height of the `bbox` field of
/// @FT_FaceRec are used to determine the horizontal and vertical
/// scaling value, respectively.
///
/// FT_SIZE_REQUEST_TYPE_CELL ::
/// The `max_advance_width` field of @FT_FaceRec is used to determine
/// the horizontal scaling value; the vertical scaling value is
/// determined the same way as @FT_SIZE_REQUEST_TYPE_REAL_DIM does.
/// Finally, both scaling values are set to the smaller one.  This type
/// is useful if you want to specify the font size for, say, a window of
/// a given dimension and 80x24 cells.
///
/// FT_SIZE_REQUEST_TYPE_SCALES ::
/// Specify the scaling values directly.
///
/// @note:
/// The above descriptions only apply to scalable formats.  For bitmap
/// formats, the behaviour is up to the driver.
///
/// See the note section of @FT_Size_Metrics if you wonder how size
/// requesting relates to scaling values.
abstract class FT_Size_Request_Type_ {
  static const int FT_SIZE_REQUEST_TYPE_NOMINAL = 0;
  static const int FT_SIZE_REQUEST_TYPE_REAL_DIM = 1;
  static const int FT_SIZE_REQUEST_TYPE_BBOX = 2;
  static const int FT_SIZE_REQUEST_TYPE_CELL = 3;
  static const int FT_SIZE_REQUEST_TYPE_SCALES = 4;
  static const int FT_SIZE_REQUEST_TYPE_MAX = 5;
}

/// @struct:
/// FT_Size_RequestRec
///
/// @description:
/// A structure to model a size request.
///
/// @fields:
/// type ::
/// See @FT_Size_Request_Type.
///
/// width ::
/// The desired width, given as a 26.6 fractional point value (with 72pt
/// = 1in).
///
/// height ::
/// The desired height, given as a 26.6 fractional point value (with
/// 72pt = 1in).
///
/// horiResolution ::
/// The horizontal resolution (dpi, i.e., pixels per inch).  If set to
/// zero, `width` is treated as a 26.6 fractional **pixel** value, which
/// gets internally rounded to an integer.
///
/// vertResolution ::
/// The vertical resolution (dpi, i.e., pixels per inch).  If set to
/// zero, `height` is treated as a 26.6 fractional **pixel** value,
/// which gets internally rounded to an integer.
///
/// @note:
/// If `width` is zero, the horizontal scaling value is set equal to the
/// vertical scaling value, and vice versa.
///
/// If `type` is `FT_SIZE_REQUEST_TYPE_SCALES`, `width` and `height` are
/// interpreted directly as 16.16 fractional scaling values, without any
/// further modification, and both `horiResolution` and `vertResolution`
/// are ignored.
class FT_Size_RequestRec_ extends ffi.Struct {
  @ffi.Int32()
  external int type;

  @FT_Long()
  external int width;

  @FT_Long()
  external int height;

  @FT_UInt()
  external int horiResolution;

  @FT_UInt()
  external int vertResolution;
}

/// @struct:
/// FT_Size_Request
///
/// @description:
/// A handle to a size request structure.
typedef FT_Size_Request = ffi.Pointer<FT_Size_RequestRec_>;

/// @type:
/// FT_F26Dot6
///
/// @description:
/// A signed 26.6 fixed-point type used for vectorial pixel coordinates.
typedef FT_F26Dot6 = ffi.Long;
typedef FT_Int32 = ffi.Int;

/// @struct:
/// FT_Matrix
///
/// @description:
/// A simple structure used to store a 2x2 matrix.  Coefficients are in
/// 16.16 fixed-point format.  The computation performed is:
///
/// ```
/// x' = x*xx + y*xy
/// y' = x*yx + y*yy
/// ```
///
/// @fields:
/// xx ::
/// Matrix coefficient.
///
/// xy ::
/// Matrix coefficient.
///
/// yx ::
/// Matrix coefficient.
///
/// yy ::
/// Matrix coefficient.
typedef FT_Matrix = FT_Matrix_;

/// @enum:
/// FT_Render_Mode
///
/// @description:
/// Render modes supported by FreeType~2.  Each mode corresponds to a
/// specific type of scanline conversion performed on the outline.
///
/// For bitmap fonts and embedded bitmaps the `bitmap->pixel_mode` field
/// in the @FT_GlyphSlotRec structure gives the format of the returned
/// bitmap.
///
/// All modes except @FT_RENDER_MODE_MONO use 256 levels of opacity,
/// indicating pixel coverage.  Use linear alpha blending and gamma
/// correction to correctly render non-monochrome glyph bitmaps onto a
/// surface; see @FT_Render_Glyph.
///
/// The @FT_RENDER_MODE_SDF is a special render mode that uses up to 256
/// distance values, indicating the signed distance from the grid position
/// to the nearest outline.
///
/// @values:
/// FT_RENDER_MODE_NORMAL ::
/// Default render mode; it corresponds to 8-bit anti-aliased bitmaps.
///
/// FT_RENDER_MODE_LIGHT ::
/// This is equivalent to @FT_RENDER_MODE_NORMAL.  It is only defined as
/// a separate value because render modes are also used indirectly to
/// define hinting algorithm selectors.  See @FT_LOAD_TARGET_XXX for
/// details.
///
/// FT_RENDER_MODE_MONO ::
/// This mode corresponds to 1-bit bitmaps (with 2~levels of opacity).
///
/// FT_RENDER_MODE_LCD ::
/// This mode corresponds to horizontal RGB and BGR subpixel displays
/// like LCD screens.  It produces 8-bit bitmaps that are 3~times the
/// width of the original glyph outline in pixels, and which use the
/// @FT_PIXEL_MODE_LCD mode.
///
/// FT_RENDER_MODE_LCD_V ::
/// This mode corresponds to vertical RGB and BGR subpixel displays
/// (like PDA screens, rotated LCD displays, etc.).  It produces 8-bit
/// bitmaps that are 3~times the height of the original glyph outline in
/// pixels and use the @FT_PIXEL_MODE_LCD_V mode.
///
/// FT_RENDER_MODE_SDF ::
/// This mode corresponds to 8-bit, single-channel signed distance field
/// (SDF) bitmaps.  Each pixel in the SDF grid is the value from the
/// pixel's position to the nearest glyph's outline.  The distances are
/// calculated from the center of the pixel and are positive if they are
/// filled by the outline (i.e., inside the outline) and negative
/// otherwise.  Check the note below on how to convert the output values
/// to usable data.
///
/// @note:
/// The selected render mode only affects vector glyphs of a font.
/// Embedded bitmaps often have a different pixel mode like
/// @FT_PIXEL_MODE_MONO.  You can use @FT_Bitmap_Convert to transform them
/// into 8-bit pixmaps.
///
/// For @FT_RENDER_MODE_SDF the output bitmap buffer contains normalized
/// distances that are packed into unsigned 8-bit values.  To get pixel
/// values in floating point representation use the following pseudo-C
/// code for the conversion.
///
/// ```
/// // Load glyph and render using FT_RENDER_MODE_SDF,
/// // then use the output buffer as follows.
///
/// ...
/// FT_Byte  buffer = glyph->bitmap->buffer;
///
///
/// for pixel in buffer
/// {
/// // `sd` is the signed distance and `spread` is the current spread;
/// // the default spread is 2 and can be changed.
///
/// float  sd = (float)pixel - 128.0f;
///
///
/// // Convert to pixel values.
/// sd = ( sd / 128.0f ) * spread;
///
/// // Store `sd` in a buffer or use as required.
/// }
///
/// ```
///
/// FreeType has two rasterizers for generating SDF, namely:
///
/// 1. `sdf` for generating SDF directly from glyph's outline, and
///
/// 2. `bsdf` for generating SDF from rasterized bitmaps.
///
/// Depending on the glyph type (i.e., outline or bitmap), one of the two
/// rasterizers is chosen at runtime and used for generating SDFs.  To
/// force the use of `bsdf` you should render the glyph with any of the
/// FreeType's other rendering modes (e.g., `FT_RENDER_MODE_NORMAL`) and
/// then re-render with `FT_RENDER_MODE_SDF`.
///
/// There are some issues with stability and possible failures of the SDF
/// renderers (specifically `sdf`).
///
/// 1. The `sdf` rasterizer is sensitive to really small features (e.g.,
/// sharp turns that are less than 1~pixel) and imperfections in the
/// glyph's outline, causing artifacts in the final output.
///
/// 2. The `sdf` rasterizer has limited support for handling intersecting
/// contours and *cannot* handle self-intersecting contours whatsoever.
/// Self-intersection happens when a single connected contour
/// intersects itself at some point; having these in your font
/// definitely poses a problem to the rasterizer and cause artifacts,
/// too.
///
/// 3. Generating SDF for really small glyphs may result in undesirable
/// output; the pixel grid (which stores distance information) becomes
/// too coarse.
///
/// 4. Since the output buffer is normalized, precision at smaller spreads
/// is greater than precision at larger spread values because the
/// output range of [0..255] gets mapped to a smaller SDF range.  A
/// spread of~2 should be sufficient in most cases.
///
/// Points (1) and (2) can be avoided by using the `bsdf` rasterizer,
/// which is more stable than the `sdf` rasterizer in general.
abstract class FT_Render_Mode_ {
  static const int FT_RENDER_MODE_NORMAL = 0;
  static const int FT_RENDER_MODE_LIGHT = 1;
  static const int FT_RENDER_MODE_MONO = 2;
  static const int FT_RENDER_MODE_LCD = 3;
  static const int FT_RENDER_MODE_LCD_V = 4;
  static const int FT_RENDER_MODE_SDF = 5;
  static const int FT_RENDER_MODE_MAX = 6;
}

/// @enum:
/// FT_Kerning_Mode
///
/// @description:
/// An enumeration to specify the format of kerning values returned by
/// @FT_Get_Kerning.
///
/// @values:
/// FT_KERNING_DEFAULT ::
/// Return grid-fitted kerning distances in 26.6 fractional pixels.
///
/// FT_KERNING_UNFITTED ::
/// Return un-grid-fitted kerning distances in 26.6 fractional pixels.
///
/// FT_KERNING_UNSCALED ::
/// Return the kerning vector in original font units.
///
/// @note:
/// `FT_KERNING_DEFAULT` returns full pixel values; it also makes FreeType
/// heuristically scale down kerning distances at small ppem values so
/// that they don't become too big.
///
/// Both `FT_KERNING_DEFAULT` and `FT_KERNING_UNFITTED` use the current
/// horizontal scaling factor (as set e.g. with @FT_Set_Char_Size) to
/// convert font units to pixels.
abstract class FT_Kerning_Mode_ {
  static const int FT_KERNING_DEFAULT = 0;
  static const int FT_KERNING_UNFITTED = 1;
  static const int FT_KERNING_UNSCALED = 2;
}

typedef FT_UInt32 = ffi.UnsignedInt;

/// @type:
/// FT_Bool
///
/// @description:
/// A typedef of unsigned char, used for simple booleans.  As usual,
/// values 1 and~0 represent true and false, respectively.
typedef FT_Bool = ffi.UnsignedChar;

const int FT_Mod_Err_Base = 0;

const int FT_Mod_Err_Autofit = 0;

const int FT_Mod_Err_BDF = 0;

const int FT_Mod_Err_Bzip2 = 0;

const int FT_Mod_Err_Cache = 0;

const int FT_Mod_Err_CFF = 0;

const int FT_Mod_Err_CID = 0;

const int FT_Mod_Err_Gzip = 0;

const int FT_Mod_Err_LZW = 0;

const int FT_Mod_Err_OTvalid = 0;

const int FT_Mod_Err_PCF = 0;

const int FT_Mod_Err_PFR = 0;

const int FT_Mod_Err_PSaux = 0;

const int FT_Mod_Err_PShinter = 0;

const int FT_Mod_Err_PSnames = 0;

const int FT_Mod_Err_Raster = 0;

const int FT_Mod_Err_SFNT = 0;

const int FT_Mod_Err_Smooth = 0;

const int FT_Mod_Err_TrueType = 0;

const int FT_Mod_Err_Type1 = 0;

const int FT_Mod_Err_Type42 = 0;

const int FT_Mod_Err_Winfonts = 0;

const int FT_Mod_Err_GXvalid = 0;

const int FT_Mod_Err_Sdf = 0;

const int FT_Mod_Err_Max = 1;

const int FT_Err_Ok = 0;

const int FT_Err_Cannot_Open_Resource = 1;

const int FT_Err_Unknown_File_Format = 2;

const int FT_Err_Invalid_File_Format = 3;

const int FT_Err_Invalid_Version = 4;

const int FT_Err_Lower_Module_Version = 5;

const int FT_Err_Invalid_Argument = 6;

const int FT_Err_Unimplemented_Feature = 7;

const int FT_Err_Invalid_Table = 8;

const int FT_Err_Invalid_Offset = 9;

const int FT_Err_Array_Too_Large = 10;

const int FT_Err_Missing_Module = 11;

const int FT_Err_Missing_Property = 12;

const int FT_Err_Invalid_Glyph_Index = 16;

const int FT_Err_Invalid_Character_Code = 17;

const int FT_Err_Invalid_Glyph_Format = 18;

const int FT_Err_Cannot_Render_Glyph = 19;

const int FT_Err_Invalid_Outline = 20;

const int FT_Err_Invalid_Composite = 21;

const int FT_Err_Too_Many_Hints = 22;

const int FT_Err_Invalid_Pixel_Size = 23;

const int FT_Err_Invalid_SVG_Document = 24;

const int FT_Err_Invalid_Handle = 32;

const int FT_Err_Invalid_Library_Handle = 33;

const int FT_Err_Invalid_Driver_Handle = 34;

const int FT_Err_Invalid_Face_Handle = 35;

const int FT_Err_Invalid_Size_Handle = 36;

const int FT_Err_Invalid_Slot_Handle = 37;

const int FT_Err_Invalid_CharMap_Handle = 38;

const int FT_Err_Invalid_Cache_Handle = 39;

const int FT_Err_Invalid_Stream_Handle = 40;

const int FT_Err_Too_Many_Drivers = 48;

const int FT_Err_Too_Many_Extensions = 49;

const int FT_Err_Out_Of_Memory = 64;

const int FT_Err_Unlisted_Object = 65;

const int FT_Err_Cannot_Open_Stream = 81;

const int FT_Err_Invalid_Stream_Seek = 82;

const int FT_Err_Invalid_Stream_Skip = 83;

const int FT_Err_Invalid_Stream_Read = 84;

const int FT_Err_Invalid_Stream_Operation = 85;

const int FT_Err_Invalid_Frame_Operation = 86;

const int FT_Err_Nested_Frame_Access = 87;

const int FT_Err_Invalid_Frame_Read = 88;

const int FT_Err_Raster_Uninitialized = 96;

const int FT_Err_Raster_Corrupted = 97;

const int FT_Err_Raster_Overflow = 98;

const int FT_Err_Raster_Negative_Height = 99;

const int FT_Err_Too_Many_Caches = 112;

const int FT_Err_Invalid_Opcode = 128;

const int FT_Err_Too_Few_Arguments = 129;

const int FT_Err_Stack_Overflow = 130;

const int FT_Err_Code_Overflow = 131;

const int FT_Err_Bad_Argument = 132;

const int FT_Err_Divide_By_Zero = 133;

const int FT_Err_Invalid_Reference = 134;

const int FT_Err_Debug_OpCode = 135;

const int FT_Err_ENDF_In_Exec_Stream = 136;

const int FT_Err_Nested_DEFS = 137;

const int FT_Err_Invalid_CodeRange = 138;

const int FT_Err_Execution_Too_Long = 139;

const int FT_Err_Too_Many_Function_Defs = 140;

const int FT_Err_Too_Many_Instruction_Defs = 141;

const int FT_Err_Table_Missing = 142;

const int FT_Err_Horiz_Header_Missing = 143;

const int FT_Err_Locations_Missing = 144;

const int FT_Err_Name_Table_Missing = 145;

const int FT_Err_CMap_Table_Missing = 146;

const int FT_Err_Hmtx_Table_Missing = 147;

const int FT_Err_Post_Table_Missing = 148;

const int FT_Err_Invalid_Horiz_Metrics = 149;

const int FT_Err_Invalid_CharMap_Format = 150;

const int FT_Err_Invalid_PPem = 151;

const int FT_Err_Invalid_Vert_Metrics = 152;

const int FT_Err_Could_Not_Find_Context = 153;

const int FT_Err_Invalid_Post_Table_Format = 154;

const int FT_Err_Invalid_Post_Table = 155;

const int FT_Err_DEF_In_Glyf_Bytecode = 156;

const int FT_Err_Missing_Bitmap = 157;

const int FT_Err_Missing_SVG_Hooks = 158;

const int FT_Err_Syntax_Error = 160;

const int FT_Err_Stack_Underflow = 161;

const int FT_Err_Ignore = 162;

const int FT_Err_No_Unicode_Glyph_Name = 163;

const int FT_Err_Glyph_Too_Big = 164;

const int FT_Err_Missing_Startfont_Field = 176;

const int FT_Err_Missing_Font_Field = 177;

const int FT_Err_Missing_Size_Field = 178;

const int FT_Err_Missing_Fontboundingbox_Field = 179;

const int FT_Err_Missing_Chars_Field = 180;

const int FT_Err_Missing_Startchar_Field = 181;

const int FT_Err_Missing_Encoding_Field = 182;

const int FT_Err_Missing_Bbx_Field = 183;

const int FT_Err_Bbx_Too_Big = 184;

const int FT_Err_Corrupted_Font_Header = 185;

const int FT_Err_Corrupted_Font_Glyphs = 186;

const int FT_Err_Max = 187;

const int FT_RENDER_POOL_SIZE = 16384;

const int FT_MAX_MODULES = 32;

const int TT_CONFIG_OPTION_SUBPIXEL_HINTING = 2;

const int TT_CONFIG_OPTION_MAX_RUNNABLE_OPCODES = 1000000;

const int T1_MAX_DICT_DEPTH = 5;

const int T1_MAX_SUBRS_CALLS = 16;

const int T1_MAX_CHARSTRINGS_OPERANDS = 256;

const int CFF_CONFIG_OPTION_DARKENING_PARAMETER_X1 = 500;

const int CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y1 = 400;

const int CFF_CONFIG_OPTION_DARKENING_PARAMETER_X2 = 1000;

const int CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y2 = 275;

const int CFF_CONFIG_OPTION_DARKENING_PARAMETER_X3 = 1667;

const int CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y3 = 275;

const int CFF_CONFIG_OPTION_DARKENING_PARAMETER_X4 = 2333;

const int CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y4 = 0;

const int NULL = 0;

const int _LIBC_LIMITS_H_ = 1;

const int _FEATURES_H = 1;

const int _DEFAULT_SOURCE = 1;

const int __GLIBC_USE_ISOC2X = 1;

const int __USE_ISOC11 = 1;

const int __USE_ISOC99 = 1;

const int __USE_ISOC95 = 1;

const int _POSIX_SOURCE = 1;

const int _POSIX_C_SOURCE = 200809;

const int __USE_POSIX = 1;

const int __USE_POSIX2 = 1;

const int __USE_POSIX199309 = 1;

const int __USE_POSIX199506 = 1;

const int __USE_XOPEN2K = 1;

const int __USE_XOPEN2K8 = 1;

const int _ATFILE_SOURCE = 1;

const int __WORDSIZE = 64;

const int __WORDSIZE_TIME64_COMPAT32 = 1;

const int __SYSCALL_WORDSIZE = 64;

const int __TIMESIZE = 64;

const int __USE_MISC = 1;

const int __USE_ATFILE = 1;

const int __USE_FORTIFY_LEVEL = 0;

const int __GLIBC_USE_DEPRECATED_GETS = 0;

const int __GLIBC_USE_DEPRECATED_SCANF = 0;

const int _STDC_PREDEF_H = 1;

const int __STDC_IEC_559__ = 1;

const int __STDC_IEC_559_COMPLEX__ = 1;

const int __STDC_ISO_10646__ = 201706;

const int __GNU_LIBRARY__ = 6;

const int __GLIBC__ = 2;

const int __GLIBC_MINOR__ = 31;

const int _SYS_CDEFS_H = 1;

const int __glibc_c99_flexarr_available = 1;

const int __HAVE_GENERIC_SELECTION = 0;

const int __GLIBC_USE_LIB_EXT2 = 1;

const int __GLIBC_USE_IEC_60559_BFP_EXT = 1;

const int __GLIBC_USE_IEC_60559_BFP_EXT_C2X = 1;

const int __GLIBC_USE_IEC_60559_FUNCS_EXT = 1;

const int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X = 1;

const int __GLIBC_USE_IEC_60559_TYPES_EXT = 1;

const int MB_LEN_MAX = 16;

const int LLONG_MIN = -9223372036854775808;

const int LLONG_MAX = 9223372036854775807;

const int ULLONG_MAX = -1;

const int _BITS_POSIX1_LIM_H = 1;

const int _POSIX_AIO_LISTIO_MAX = 2;

const int _POSIX_AIO_MAX = 1;

const int _POSIX_ARG_MAX = 4096;

const int _POSIX_CHILD_MAX = 25;

const int _POSIX_DELAYTIMER_MAX = 32;

const int _POSIX_HOST_NAME_MAX = 255;

const int _POSIX_LINK_MAX = 8;

const int _POSIX_LOGIN_NAME_MAX = 9;

const int _POSIX_MAX_CANON = 255;

const int _POSIX_MAX_INPUT = 255;

const int _POSIX_MQ_OPEN_MAX = 8;

const int _POSIX_MQ_PRIO_MAX = 32;

const int _POSIX_NAME_MAX = 14;

const int _POSIX_NGROUPS_MAX = 8;

const int _POSIX_OPEN_MAX = 20;

const int _POSIX_PATH_MAX = 256;

const int _POSIX_PIPE_BUF = 512;

const int _POSIX_RE_DUP_MAX = 255;

const int _POSIX_RTSIG_MAX = 8;

const int _POSIX_SEM_NSEMS_MAX = 256;

const int _POSIX_SEM_VALUE_MAX = 32767;

const int _POSIX_SIGQUEUE_MAX = 32;

const int _POSIX_SSIZE_MAX = 32767;

const int _POSIX_STREAM_MAX = 8;

const int _POSIX_SYMLINK_MAX = 255;

const int _POSIX_SYMLOOP_MAX = 8;

const int _POSIX_TIMER_MAX = 32;

const int _POSIX_TTY_NAME_MAX = 9;

const int _POSIX_TZNAME_MAX = 6;

const int _POSIX_CLOCKRES_MIN = 20000000;

const int NGROUPS_MAX = 65536;

const int MAX_CANON = 255;

const int MAX_INPUT = 255;

const int NAME_MAX = 255;

const int PATH_MAX = 4096;

const int PIPE_BUF = 4096;

const int XATTR_NAME_MAX = 255;

const int XATTR_SIZE_MAX = 65536;

const int XATTR_LIST_MAX = 65536;

const int RTSIG_MAX = 32;

const int _POSIX_THREAD_KEYS_MAX = 128;

const int PTHREAD_KEYS_MAX = 1024;

const int _POSIX_THREAD_DESTRUCTOR_ITERATIONS = 4;

const int PTHREAD_DESTRUCTOR_ITERATIONS = 4;

const int _POSIX_THREAD_THREADS_MAX = 64;

const int AIO_PRIO_DELTA_MAX = 20;

const int PTHREAD_STACK_MIN = 16384;

const int DELAYTIMER_MAX = 2147483647;

const int TTY_NAME_MAX = 32;

const int LOGIN_NAME_MAX = 256;

const int HOST_NAME_MAX = 64;

const int MQ_PRIO_MAX = 32768;

const int SEM_VALUE_MAX = 2147483647;

const int SSIZE_MAX = 9223372036854775807;

const int _BITS_POSIX2_LIM_H = 1;

const int _POSIX2_BC_BASE_MAX = 99;

const int _POSIX2_BC_DIM_MAX = 2048;

const int _POSIX2_BC_SCALE_MAX = 99;

const int _POSIX2_BC_STRING_MAX = 1000;

const int _POSIX2_COLL_WEIGHTS_MAX = 2;

const int _POSIX2_EXPR_NEST_MAX = 32;

const int _POSIX2_LINE_MAX = 2048;

const int _POSIX2_RE_DUP_MAX = 255;

const int _POSIX2_CHARCLASS_NAME_MAX = 14;

const int BC_BASE_MAX = 99;

const int BC_DIM_MAX = 2048;

const int BC_SCALE_MAX = 99;

const int BC_STRING_MAX = 1000;

const int COLL_WEIGHTS_MAX = 255;

const int EXPR_NEST_MAX = 32;

const int LINE_MAX = 2048;

const int CHARCLASS_NAME_MAX = 2048;

const int RE_DUP_MAX = 32767;

const int SCHAR_MAX = 127;

const int SHRT_MAX = 32767;

const int INT_MAX = 2147483647;

const int LONG_MAX = 9223372036854775807;

const int SCHAR_MIN = -128;

const int SHRT_MIN = -32768;

const int INT_MIN = -2147483648;

const int LONG_MIN = -9223372036854775808;

const int UCHAR_MAX = 255;

const int USHRT_MAX = 65535;

const int UINT_MAX = 4294967295;

const int ULONG_MAX = -1;

const int CHAR_BIT = 8;

const int CHAR_MIN = -128;

const int CHAR_MAX = 127;

const int FT_CHAR_BIT = 8;

const int FT_USHORT_MAX = 65535;

const int FT_INT_MAX = 2147483647;

const int FT_INT_MIN = -2147483648;

const int FT_UINT_MAX = 4294967295;

const int FT_LONG_MIN = -9223372036854775808;

const int FT_LONG_MAX = 9223372036854775807;

const int FT_ULONG_MAX = -1;

const int FT_LLONG_MAX = 9223372036854775807;

const int FT_LLONG_MIN = -9223372036854775808;

const int FT_ULLONG_MAX = -1;

const int _STRING_H = 1;

const int _BITS_TYPES_LOCALE_T_H = 1;

const int _BITS_TYPES___LOCALE_T_H = 1;

const int _STRINGS_H = 1;

const int _STDIO_H = 1;

const int __GNUC_VA_LIST = 1;

const int _BITS_TYPES_H = 1;

const int _BITS_TYPESIZES_H = 1;

const int __OFF_T_MATCHES_OFF64_T = 1;

const int __INO_T_MATCHES_INO64_T = 1;

const int __RLIM_T_MATCHES_RLIM64_T = 1;

const int __STATFS_MATCHES_STATFS64 = 1;

const int __FD_SETSIZE = 1024;

const int _BITS_TIME64_H = 1;

const int _____fpos_t_defined = 1;

const int ____mbstate_t_defined = 1;

const int _____fpos64_t_defined = 1;

const int ____FILE_defined = 1;

const int __FILE_defined = 1;

const int __struct_FILE_defined = 1;

const int _IO_EOF_SEEN = 16;

const int _IO_ERR_SEEN = 32;

const int _IO_USER_LOCK = 32768;

const int _IOFBF = 0;

const int _IOLBF = 1;

const int _IONBF = 2;

const int BUFSIZ = 8192;

const int EOF = -1;

const int SEEK_SET = 0;

const int SEEK_CUR = 1;

const int SEEK_END = 2;

const String P_tmpdir = '/tmp';

const int _BITS_STDIO_LIM_H = 1;

const int L_tmpnam = 20;

const int TMP_MAX = 238328;

const int FILENAME_MAX = 4096;

const int L_ctermid = 9;

const int FOPEN_MAX = 16;

const int __HAVE_FLOAT128 = 0;

const int __HAVE_DISTINCT_FLOAT128 = 0;

const int __HAVE_FLOAT64X = 1;

const int __HAVE_FLOAT64X_LONG_DOUBLE = 1;

const int __HAVE_FLOAT16 = 0;

const int __HAVE_FLOAT32 = 1;

const int __HAVE_FLOAT64 = 1;

const int __HAVE_FLOAT32X = 1;

const int __HAVE_FLOAT128X = 0;

const int __HAVE_DISTINCT_FLOAT16 = 0;

const int __HAVE_DISTINCT_FLOAT32 = 0;

const int __HAVE_DISTINCT_FLOAT64 = 0;

const int __HAVE_DISTINCT_FLOAT32X = 0;

const int __HAVE_DISTINCT_FLOAT64X = 0;

const int __HAVE_DISTINCT_FLOAT128X = 0;

const int __HAVE_FLOAT128_UNLIKE_LDBL = 0;

const int __HAVE_FLOATN_NOT_TYPEDEF = 0;

const int _STDLIB_H = 1;

const int WNOHANG = 1;

const int WUNTRACED = 2;

const int WSTOPPED = 2;

const int WEXITED = 4;

const int WCONTINUED = 8;

const int WNOWAIT = 16777216;

const int __WNOTHREAD = 536870912;

const int __WALL = 1073741824;

const int __WCLONE = 2147483648;

const int __W_CONTINUED = 65535;

const int __WCOREFLAG = 128;

const int __ldiv_t_defined = 1;

const int __lldiv_t_defined = 1;

const int RAND_MAX = 2147483647;

const int EXIT_FAILURE = 1;

const int EXIT_SUCCESS = 0;

const int _SYS_TYPES_H = 1;

const int __clock_t_defined = 1;

const int __clockid_t_defined = 1;

const int __time_t_defined = 1;

const int __timer_t_defined = 1;

const int _BITS_STDINT_INTN_H = 1;

const int __BIT_TYPES_DEFINED__ = 1;

const int _ENDIAN_H = 1;

const int _BITS_ENDIAN_H = 1;

const int __LITTLE_ENDIAN = 1234;

const int __BIG_ENDIAN = 4321;

const int __PDP_ENDIAN = 3412;

const int _BITS_ENDIANNESS_H = 1;

const int __BYTE_ORDER = 1234;

const int __FLOAT_WORD_ORDER = 1234;

const int LITTLE_ENDIAN = 1234;

const int BIG_ENDIAN = 4321;

const int PDP_ENDIAN = 3412;

const int BYTE_ORDER = 1234;

const int _BITS_BYTESWAP_H = 1;

const int _BITS_UINTN_IDENTITY_H = 1;

const int _SYS_SELECT_H = 1;

const int __sigset_t_defined = 1;

const int _SIGSET_NWORDS = 16;

const int __timeval_defined = 1;

const int _STRUCT_TIMESPEC = 1;

const int __NFDBITS = 64;

const int FD_SETSIZE = 1024;

const int NFDBITS = 64;

const int _BITS_PTHREADTYPES_COMMON_H = 1;

const int _THREAD_SHARED_TYPES_H = 1;

const int _BITS_PTHREADTYPES_ARCH_H = 1;

const int __SIZEOF_PTHREAD_MUTEX_T = 40;

const int __SIZEOF_PTHREAD_ATTR_T = 56;

const int __SIZEOF_PTHREAD_RWLOCK_T = 56;

const int __SIZEOF_PTHREAD_BARRIER_T = 32;

const int __SIZEOF_PTHREAD_MUTEXATTR_T = 4;

const int __SIZEOF_PTHREAD_COND_T = 48;

const int __SIZEOF_PTHREAD_CONDATTR_T = 4;

const int __SIZEOF_PTHREAD_RWLOCKATTR_T = 8;

const int __SIZEOF_PTHREAD_BARRIERATTR_T = 4;

const int _THREAD_MUTEX_INTERNAL_H = 1;

const int __PTHREAD_MUTEX_HAVE_PREV = 1;

const int __PTHREAD_RWLOCK_ELISION_EXTRA = 0;

const int __have_pthread_attr_t = 1;

const int _ALLOCA_H = 1;

const int _SETJMP_H = 1;

const int _BITS_SETJMP_H = 1;

const int FT_SIZEOF_INT = 4;

const int FT_SIZEOF_LONG = 8;

const int FT_SIZEOF_LONG_LONG = 8;

const int ft_pixel_mode_none = 0;

const int ft_pixel_mode_mono = 1;

const int ft_pixel_mode_grays = 2;

const int ft_pixel_mode_pal2 = 3;

const int ft_pixel_mode_pal4 = 4;

const int FT_OUTLINE_CONTOURS_MAX = 32767;

const int FT_OUTLINE_POINTS_MAX = 32767;

const int FT_OUTLINE_NONE = 0;

const int FT_OUTLINE_OWNER = 1;

const int FT_OUTLINE_EVEN_ODD_FILL = 2;

const int FT_OUTLINE_REVERSE_FILL = 4;

const int FT_OUTLINE_IGNORE_DROPOUTS = 8;

const int FT_OUTLINE_SMART_DROPOUTS = 16;

const int FT_OUTLINE_INCLUDE_STUBS = 32;

const int FT_OUTLINE_OVERLAP = 64;

const int FT_OUTLINE_HIGH_PRECISION = 256;

const int FT_OUTLINE_SINGLE_PASS = 512;

const int ft_outline_none = 0;

const int ft_outline_owner = 1;

const int ft_outline_even_odd_fill = 2;

const int ft_outline_reverse_fill = 4;

const int ft_outline_ignore_dropouts = 8;

const int ft_outline_high_precision = 256;

const int ft_outline_single_pass = 512;

const int FT_CURVE_TAG_ON = 1;

const int FT_CURVE_TAG_CONIC = 0;

const int FT_CURVE_TAG_CUBIC = 2;

const int FT_CURVE_TAG_HAS_SCANMODE = 4;

const int FT_CURVE_TAG_TOUCH_X = 8;

const int FT_CURVE_TAG_TOUCH_Y = 16;

const int FT_CURVE_TAG_TOUCH_BOTH = 24;

const int FT_Curve_Tag_On = 1;

const int FT_Curve_Tag_Conic = 0;

const int FT_Curve_Tag_Cubic = 2;

const int FT_Curve_Tag_Touch_X = 8;

const int FT_Curve_Tag_Touch_Y = 16;

const int ft_glyph_format_none = 0;

const int ft_glyph_format_composite = 1668246896;

const int ft_glyph_format_bitmap = 1651078259;

const int ft_glyph_format_outline = 1869968492;

const int ft_glyph_format_plotter = 1886154612;

const int FT_RASTER_FLAG_DEFAULT = 0;

const int FT_RASTER_FLAG_AA = 1;

const int FT_RASTER_FLAG_DIRECT = 2;

const int FT_RASTER_FLAG_CLIP = 4;

const int FT_RASTER_FLAG_SDF = 8;

const int ft_raster_flag_default = 0;

const int ft_raster_flag_aa = 1;

const int ft_raster_flag_direct = 2;

const int ft_raster_flag_clip = 4;

const int ft_encoding_none = 0;

const int ft_encoding_unicode = 1970170211;

const int ft_encoding_symbol = 1937337698;

const int ft_encoding_latin_1 = 1818326065;

const int ft_encoding_latin_2 = 1818326066;

const int ft_encoding_sjis = 1936353651;

const int ft_encoding_gb2312 = 1734484000;

const int ft_encoding_big5 = 1651074869;

const int ft_encoding_wansung = 2002873971;

const int ft_encoding_johab = 1785686113;

const int ft_encoding_adobe_standard = 1094995778;

const int ft_encoding_adobe_expert = 1094992453;

const int ft_encoding_adobe_custom = 1094992451;

const int ft_encoding_apple_roman = 1634889070;

const int FT_FACE_FLAG_SCALABLE = 1;

const int FT_FACE_FLAG_FIXED_SIZES = 2;

const int FT_FACE_FLAG_FIXED_WIDTH = 4;

const int FT_FACE_FLAG_SFNT = 8;

const int FT_FACE_FLAG_HORIZONTAL = 16;

const int FT_FACE_FLAG_VERTICAL = 32;

const int FT_FACE_FLAG_KERNING = 64;

const int FT_FACE_FLAG_FAST_GLYPHS = 128;

const int FT_FACE_FLAG_MULTIPLE_MASTERS = 256;

const int FT_FACE_FLAG_GLYPH_NAMES = 512;

const int FT_FACE_FLAG_EXTERNAL_STREAM = 1024;

const int FT_FACE_FLAG_HINTER = 2048;

const int FT_FACE_FLAG_CID_KEYED = 4096;

const int FT_FACE_FLAG_TRICKY = 8192;

const int FT_FACE_FLAG_COLOR = 16384;

const int FT_FACE_FLAG_VARIATION = 32768;

const int FT_FACE_FLAG_SVG = 65536;

const int FT_FACE_FLAG_SBIX = 131072;

const int FT_FACE_FLAG_SBIX_OVERLAY = 262144;

const int FT_STYLE_FLAG_ITALIC = 1;

const int FT_STYLE_FLAG_BOLD = 2;

const int FT_OPEN_MEMORY = 1;

const int FT_OPEN_STREAM = 2;

const int FT_OPEN_PATHNAME = 4;

const int FT_OPEN_DRIVER = 8;

const int FT_OPEN_PARAMS = 16;

const int ft_open_memory = 1;

const int ft_open_stream = 2;

const int ft_open_pathname = 4;

const int ft_open_driver = 8;

const int ft_open_params = 16;

const int FT_LOAD_DEFAULT = 0;

const int FT_LOAD_NO_SCALE = 1;

const int FT_LOAD_NO_HINTING = 2;

const int FT_LOAD_RENDER = 4;

const int FT_LOAD_NO_BITMAP = 8;

const int FT_LOAD_VERTICAL_LAYOUT = 16;

const int FT_LOAD_FORCE_AUTOHINT = 32;

const int FT_LOAD_CROP_BITMAP = 64;

const int FT_LOAD_PEDANTIC = 128;

const int FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH = 512;

const int FT_LOAD_NO_RECURSE = 1024;

const int FT_LOAD_IGNORE_TRANSFORM = 2048;

const int FT_LOAD_MONOCHROME = 4096;

const int FT_LOAD_LINEAR_DESIGN = 8192;

const int FT_LOAD_SBITS_ONLY = 16384;

const int FT_LOAD_NO_AUTOHINT = 32768;

const int FT_LOAD_COLOR = 1048576;

const int FT_LOAD_COMPUTE_METRICS = 2097152;

const int FT_LOAD_BITMAP_METRICS_ONLY = 4194304;

const int FT_LOAD_ADVANCE_ONLY = 256;

const int FT_LOAD_SVG_ONLY = 8388608;

const int FT_LOAD_TARGET_NORMAL = 0;

const int FT_LOAD_TARGET_LIGHT = 65536;

const int FT_LOAD_TARGET_MONO = 131072;

const int FT_LOAD_TARGET_LCD = 196608;

const int FT_LOAD_TARGET_LCD_V = 262144;

const int ft_render_mode_normal = 0;

const int ft_render_mode_mono = 2;

const int ft_kerning_default = 0;

const int ft_kerning_unfitted = 1;

const int ft_kerning_unscaled = 2;

const int FT_SUBGLYPH_FLAG_ARGS_ARE_WORDS = 1;

const int FT_SUBGLYPH_FLAG_ARGS_ARE_XY_VALUES = 2;

const int FT_SUBGLYPH_FLAG_ROUND_XY_TO_GRID = 4;

const int FT_SUBGLYPH_FLAG_SCALE = 8;

const int FT_SUBGLYPH_FLAG_XY_SCALE = 64;

const int FT_SUBGLYPH_FLAG_2X2 = 128;

const int FT_SUBGLYPH_FLAG_USE_MY_METRICS = 512;

const int FT_FSTYPE_INSTALLABLE_EMBEDDING = 0;

const int FT_FSTYPE_RESTRICTED_LICENSE_EMBEDDING = 2;

const int FT_FSTYPE_PREVIEW_AND_PRINT_EMBEDDING = 4;

const int FT_FSTYPE_EDITABLE_EMBEDDING = 8;

const int FT_FSTYPE_NO_SUBSETTING = 256;

const int FT_FSTYPE_BITMAP_EMBEDDING_ONLY = 512;

const int FREETYPE_MAJOR = 2;

const int FREETYPE_MINOR = 12;

const int FREETYPE_PATCH = 1;
